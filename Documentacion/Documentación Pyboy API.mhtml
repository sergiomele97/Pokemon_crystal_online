From: <Saved by Blink>
Snapshot-Content-Location: https://docs.pyboy.dk/index.html
Subject: pyboy API documentation
Date: Thu, 13 Jun 2024 10:30:41 +0200
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----"


------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/html
Content-ID: <frame-D0A36DE5C7538385819785775F84B79F@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://docs.pyboy.dk/index.html

<!DOCTYPE html><html lang=3D"en"><head><meta http-equiv=3D"Content-Type" co=
ntent=3D"text/html; charset=3DUTF-8"><link rel=3D"stylesheet" type=3D"text/=
css" href=3D"cid:css-f8f9f4c2-91cf-4773-bd31-e89e96c94627@mhtml.blink" /><l=
ink rel=3D"stylesheet" type=3D"text/css" href=3D"cid:css-4c5add56-c960-40d9=
-877a-ae82dbdb270c@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css=
" href=3D"cid:css-48a2acaa-0840-4821-98e3-28b1f23329fe@mhtml.blink" /><link=
 rel=3D"stylesheet" type=3D"text/css" href=3D"cid:css-955b1811-73a3-4a0a-bd=
92-692c2e1ce0d1@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css" h=
ref=3D"cid:css-a9dbe30a-3e08-472c-bb8a-cc4025cad437@mhtml.blink" /><link re=
l=3D"stylesheet" type=3D"text/css" href=3D"cid:css-4ae5926d-a767-4682-8dd1-=
705f0032e30b@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css" href=
=3D"cid:css-411f6874-bea2-43d5-988c-a38a6c1d45d5@mhtml.blink" /><link rel=
=3D"stylesheet" type=3D"text/css" href=3D"cid:css-990ddaa9-fc7f-47ac-bc6b-8=
ea109ceacfe@mhtml.blink" /><link rel=3D"stylesheet" type=3D"text/css" href=
=3D"cid:css-67ae9d7c-82c3-4c78-8764-5db53d1e67bb@mhtml.blink" /><link rel=
=3D"stylesheet" type=3D"text/css" href=3D"cid:css-40fc8bd7-9d8e-4669-811a-c=
24898ff1469@mhtml.blink" />

<meta name=3D"viewport" content=3D"width=3Ddevice-width, initial-scale=3D1,=
 minimum-scale=3D1">
<meta name=3D"generator" content=3D"pdoc 0.10.0">
<title>pyboy API documentation</title>
<meta name=3D"description" content=3D"">
<link href=3D"https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normal=
ize.min.css" rel=3D"stylesheet">
<link href=3D"https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.=
0/sanitize.min.css" rel=3D"stylesheet">
<link href=3D"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/st=
yles/github.min.css" rel=3D"stylesheet">




</head>
<body><div id=3D"MathJax_Message" style=3D"display: none;"></div>
<main>
<article id=3D"content">
<header>
<h1 class=3D"title">Module <code>pyboy</code></h1>
</header>
<section id=3D"section-intro">
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-comment">#</span>
<span class=3D"hljs-comment"># License: See LICENSE.md file</span>
<span class=3D"hljs-comment"># GitHub: https://github.com/Baekalfen/PyBoy</=
span>
<span class=3D"hljs-comment">#</span>

__pdoc__ =3D {
    <span class=3D"hljs-string">"core"</span>: <span class=3D"hljs-keyword"=
>False</span>,
    <span class=3D"hljs-string">"logging"</span>: <span class=3D"hljs-keywo=
rd">False</span>,
    <span class=3D"hljs-string">"pyboy"</span>: <span class=3D"hljs-keyword=
">False</span>,
    <span class=3D"hljs-string">"conftest"</span>: <span class=3D"hljs-keyw=
ord">False</span>,
}

__all__ =3D [<span class=3D"hljs-string">"PyBoy"</span>, <span class=3D"hlj=
s-string">"PyBoyMemoryView"</span>, <span class=3D"hljs-string">"PyBoyRegis=
terFile"</span>]

<span class=3D"hljs-keyword">from</span> .pyboy <span class=3D"hljs-keyword=
">import</span> PyBoy, PyBoyMemoryView, PyBoyRegisterFile</code></pre>
</details>
</section>
<section>
<h2 class=3D"section-title" id=3D"header-submodules">Sub-modules</h2>
<dl>
<dt><code class=3D"name"><a title=3D"pyboy.api" href=3D"https://docs.pyboy.=
dk/api/index.html">pyboy.api</a></code></dt>
<dd>
<section class=3D"desc"><p>Tools to help interfacing with the Game Boy hard=
ware</p></section>
</dd>
<dt><code class=3D"name"><a title=3D"pyboy.plugins" href=3D"https://docs.py=
boy.dk/plugins/index.html">pyboy.plugins</a></code></dt>
<dd>
<section class=3D"desc"><p>Plugins that extend PyBoy's functionality. The o=
nly publicly exposed, are the game wrappers.</p></section>
</dd>
<dt><code class=3D"name"><a title=3D"pyboy.utils" href=3D"https://docs.pybo=
y.dk/utils.html">pyboy.utils</a></code></dt>
<dd>
<section class=3D"desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class=3D"section-title" id=3D"header-classes">Classes</h2>
<dl>
<dt id=3D"pyboy.PyBoy"><code class=3D"flex name class">
<span>class <span class=3D"ident">PyBoy</span></span>
<span>(</span><span>gamerom, *, window=3D'SDL2', scale=3D3, symbols=3DNone,=
 bootrom=3DNone, sound=3DFalse, sound_emulated=3DFalse, cgb=3DNone, log_lev=
el=3D'ERROR', **kwargs)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>PyBoy is loadable as an object in Python. This m=
eans, it can be initialized from another script, and be
controlled and probed by the script. It is supported to spawn multiple emul=
ators, just instantiate the class
multiple times.</p>
<p>A range of methods are exposed, which should allow for complete control =
of the emulator. Please open an issue on
GitHub, if other methods are needed for your projects. Take a look at the f=
iles in <code>examples/</code> for a crude
"bots", which interact with the game.</p>
<p>Only the <code>gamerom</code> argument is required.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy =3D PyBoy(<span class=3D"hljs-string">'game_rom.gb'</spa=
n>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
for</span> _ <span class=3D"hljs-keyword">in</span> range(<span class=3D"hl=
js-number">60</span>): <span class=3D"hljs-comment"># Use 'while True:' for=
 infinite</span>
<span class=3D"hljs-meta">... </span>    pyboy.tick()
<span class=3D"hljs-keyword">True</span>...
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.stop()

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>gamerom</code></strong> :=E2=80=82<code>str</code></dt>
<dd>Filepath to a game-ROM for Game Boy or Game Boy Color.</dd>
</dl>
<h2 id=3D"kwargs">Kwargs</h2>
<ul>
<li>window (str): "SDL2", "OpenGL", or "null"</li>
<li>scale (int): Window scale factor. Doesn't apply to API.</li>
<li>symbols (str): Filepath to a .sym file to use. If unsure, specify <code=
>None</code>.</li>
<li>bootrom (str): Filepath to a boot-ROM to use. If unsure, specify <code>=
None</code>.</li>
<li>sound (bool): Enable sound emulation and output.</li>
<li>sound_emulated (bool): Enable sound emulation without any output. Used =
for compatibility.</li>
<li>cgb (bool): Forcing Game Boy Color mode.</li>
<li>log_level (str): "CRITICAL", "ERROR", "WARNING", "INFO" or "DEBUG"</li>
<li>color_palette (tuple): Specify the color palette to use for rendering.<=
/li>
<li>cgb_color_palette (list of tuple): Specify the color palette to use for=
 rendering in CGB-mode for non-color games.</li>
</ul>
<p>Other keyword arguments may exist for plugins that are not listed here. =
They can be viewed by running <code>pyboy --help</code> in the terminal.</p=
></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-class"><span class=3D"=
hljs-keyword">class</span> <span class=3D"hljs-title">PyBoy</span>:</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__init__</span><span class=3D"hljs-params">(
        self,
        gamerom,
        *,
        window=3Ddefaults[<span class=3D"hljs-string">"window"</span>],
        scale=3Ddefaults[<span class=3D"hljs-string">"scale"</span>],
        symbols=3DNone,
        bootrom=3DNone,
        sound=3DFalse,
        sound_emulated=3DFalse,
        cgb=3DNone,
        log_level=3Ddefaults[<span class=3D"hljs-string">"log_level"</span>=
],
        **kwargs
    )</span>:</span>
        <span class=3D"hljs-string">"""
        PyBoy is loadable as an object in Python. This means, it can be ini=
tialized from another script, and be
        controlled and probed by the script. It is supported to spawn multi=
ple emulators, just instantiate the class
        multiple times.

        A range of methods are exposed, which should allow for complete con=
trol of the emulator. Please open an issue on
        GitHub, if other methods are needed for your projects. Take a look =
at the files in `examples/` for a crude
        "bots", which interact with the game.

        Only the `gamerom` argument is required.

        Example:
        ```python
        &gt;&gt;&gt; pyboy =3D PyBoy('game_rom.gb')
        &gt;&gt;&gt; for _ in range(60): # Use 'while True:' for infinite
        ...     pyboy.tick()
        True...
        &gt;&gt;&gt; pyboy.stop()

        ```

        Args:
            gamerom (str): Filepath to a game-ROM for Game Boy or Game Boy =
Color.

        Kwargs:
            * window (str): "SDL2", "OpenGL", or "null"
            * scale (int): Window scale factor. Doesn't apply to API.
            * symbols (str): Filepath to a .sym file to use. If unsure, spe=
cify `None`.
            * bootrom (str): Filepath to a boot-ROM to use. If unsure, spec=
ify `None`.
            * sound (bool): Enable sound emulation and output.
            * sound_emulated (bool): Enable sound emulation without any out=
put. Used for compatibility.
            * cgb (bool): Forcing Game Boy Color mode.
            * log_level (str): "CRITICAL", "ERROR", "WARNING", "INFO" or "D=
EBUG"
            * color_palette (tuple): Specify the color palette to use for r=
endering.
            * cgb_color_palette (list of tuple): Specify the color palette =
to use for rendering in CGB-mode for non-color games.

        Other keyword arguments may exist for plugins that are not listed h=
ere. They can be viewed by running `pyboy --help` in the terminal.
        """</span>

        self.initialized =3D <span class=3D"hljs-keyword">False</span>

        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-string">=
"bootrom_file"</span> <span class=3D"hljs-keyword">in</span> kwargs:
            logger.error(
                <span class=3D"hljs-string">"Deprecated use of 'bootrom_fil=
e'. Use 'bootrom' keyword argument instead. https://github.com/Baekalfen/Py=
Boy/wiki/Migrating-from-v1.x.x-to-v2.0.0"</span>
            )
            bootrom =3D kwargs.pop(<span class=3D"hljs-string">"bootrom_fil=
e"</span>)

        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-string">=
"window_type"</span> <span class=3D"hljs-keyword">in</span> kwargs:
            logger.error(
                <span class=3D"hljs-string">"Deprecated use of 'window_type=
'. Use 'window' keyword argument instead. https://github.com/Baekalfen/PyBo=
y/wiki/Migrating-from-v1.x.x-to-v2.0.0"</span>
            )
            window =3D kwargs.pop(<span class=3D"hljs-string">"window_type"=
</span>)

        <span class=3D"hljs-keyword">if</span> window <span class=3D"hljs-k=
eyword">not</span> <span class=3D"hljs-keyword">in</span> [<span class=3D"h=
ljs-string">"SDL2"</span>, <span class=3D"hljs-string">"OpenGL"</span>, <sp=
an class=3D"hljs-string">"null"</span>, <span class=3D"hljs-string">"headle=
ss"</span>, <span class=3D"hljs-string">"dummy"</span>]:
            <span class=3D"hljs-keyword">raise</span> KeyError(<span class=
=3D"hljs-string">f'Unknown window type: <span class=3D"hljs-subst">{window}=
</span>. Use "SDL2", "OpenGL", or "null"'</span>)

        kwargs[<span class=3D"hljs-string">"window"</span>] =3D window
        kwargs[<span class=3D"hljs-string">"scale"</span>] =3D scale
        randomize =3D kwargs.pop(<span class=3D"hljs-string">"randomize"</s=
pan>, <span class=3D"hljs-keyword">False</span>) <span class=3D"hljs-commen=
t"># Undocumented feature</span>

        <span class=3D"hljs-keyword">for</span> k, v <span class=3D"hljs-ke=
yword">in</span> defaults.items():
            <span class=3D"hljs-keyword">if</span> k <span class=3D"hljs-ke=
yword">not</span> <span class=3D"hljs-keyword">in</span> kwargs:
                kwargs[k] =3D kwargs.get(k, defaults[k])

        _log_level(log_level)

        <span class=3D"hljs-keyword">if</span> gamerom <span class=3D"hljs-=
keyword">is</span> <span class=3D"hljs-keyword">None</span>:
            <span class=3D"hljs-keyword">raise</span> FileNotFoundError(<sp=
an class=3D"hljs-string">f"None is not a ROM file!"</span>)

        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword"=
>not</span> os.path.isfile(gamerom):
            <span class=3D"hljs-keyword">raise</span> FileNotFoundError(<sp=
an class=3D"hljs-string">f"ROM file <span class=3D"hljs-subst">{gamerom}</s=
pan> was not found!"</span>)
        self.gamerom =3D gamerom

        self.rom_symbols =3D {}
        self.rom_symbols_inverse =3D {}
        <span class=3D"hljs-keyword">if</span> symbols <span class=3D"hljs-=
keyword">is</span> <span class=3D"hljs-keyword">not</span> <span class=3D"h=
ljs-keyword">None</span>:
            <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyw=
ord">not</span> os.path.isfile(symbols):
                <span class=3D"hljs-keyword">raise</span> FileNotFoundError=
(<span class=3D"hljs-string">f"Symbols file <span class=3D"hljs-subst">{sym=
bols}</span> was not found!"</span>)
        self.symbols_file =3D symbols
        self._load_symbols()

        self.mb =3D Motherboard(
            gamerom,
            bootrom,
            kwargs[<span class=3D"hljs-string">"color_palette"</span>],
            kwargs[<span class=3D"hljs-string">"cgb_color_palette"</span>],
            sound,
            sound_emulated,
            cgb,
            randomize=3Drandomize,
        )

        <span class=3D"hljs-comment"># Validate all kwargs</span>
        plugin_manager_keywords =3D []
        <span class=3D"hljs-keyword">for</span> x <span class=3D"hljs-keywo=
rd">in</span> parser_arguments():
            <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyw=
ord">not</span> x:
                <span class=3D"hljs-keyword">continue</span>
            plugin_manager_keywords.extend(z.strip(<span class=3D"hljs-stri=
ng">"-"</span>).replace(<span class=3D"hljs-string">"-"</span>, <span class=
=3D"hljs-string">"_"</span>) <span class=3D"hljs-keyword">for</span> y <spa=
n class=3D"hljs-keyword">in</span> x <span class=3D"hljs-keyword">for</span=
> z <span class=3D"hljs-keyword">in</span> y[:<span class=3D"hljs-number">-=
1</span>])

        <span class=3D"hljs-keyword">for</span> k, v <span class=3D"hljs-ke=
yword">in</span> kwargs.items():
            <span class=3D"hljs-keyword">if</span> k <span class=3D"hljs-ke=
yword">not</span> <span class=3D"hljs-keyword">in</span> defaults <span cla=
ss=3D"hljs-keyword">and</span> k <span class=3D"hljs-keyword">not</span> <s=
pan class=3D"hljs-keyword">in</span> plugin_manager_keywords:
                logger.error(<span class=3D"hljs-string">"Unknown keyword a=
rgument: %s"</span>, k)
                <span class=3D"hljs-keyword">raise</span> KeyError(<span cl=
ass=3D"hljs-string">f"Unknown keyword argument: <span class=3D"hljs-subst">=
{k}</span>"</span>)

        <span class=3D"hljs-comment"># Performance measures</span>
        self.avg_pre =3D <span class=3D"hljs-number">0</span>
        self.avg_tick =3D <span class=3D"hljs-number">0</span>
        self.avg_post =3D <span class=3D"hljs-number">0</span>

        <span class=3D"hljs-comment"># Absolute frame count of the emulatio=
n</span>
        self.frame_count =3D <span class=3D"hljs-number">0</span>

        self.set_emulation_speed(<span class=3D"hljs-number">1</span>)
        self.paused =3D <span class=3D"hljs-keyword">False</span>
        self.events =3D []
        self.queued_input =3D []
        self.quitting =3D <span class=3D"hljs-keyword">False</span>
        self.stopped =3D <span class=3D"hljs-keyword">False</span>
        self.window_title =3D <span class=3D"hljs-string">"PyBoy"</span>

        <span class=3D"hljs-comment">###################</span>
        <span class=3D"hljs-comment"># API attributes</span>
        self.screen =3D Screen(self.mb)
        <span class=3D"hljs-string">"""
        Use this method to get a `pyboy.api.screen.Screen` object. This can=
 be used to get the screen buffer in
        a variety of formats.

        It's also here you can find the screen position (SCX, SCY, WX, WY) =
for each scan line in the screen buffer. See
        `pyboy.api.screen.Screen.tilemap_position_list` for more informatio=
n.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.screen.image.show()
        &gt;&gt;&gt; pyboy.screen.ndarray.shape
        (144, 160, 4)
        &gt;&gt;&gt; pyboy.screen.raw_buffer_format
        'RGBA'

        ```

        Returns
        -------
        `pyboy.api.screen.Screen`:
            A Screen object with helper functions for reading the screen bu=
ffer.
        """</span>
        self.memory =3D PyBoyMemoryView(self.mb)
        <span class=3D"hljs-string">"""
        Provides a `pyboy.PyBoyMemoryView` object for reading and writing t=
he memory space of the Game Boy.

        For a more comprehensive description, see the `pyboy.PyBoyMemoryVie=
w` class.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.memory[0x0000:0x0010] # Read 16 bytes from ROM b=
ank 0
        [49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, =
33]
        &gt;&gt;&gt; pyboy.memory[1, 0x2000] =3D 12 # Override address 0x20=
00 from ROM bank 1 with the value 12
        &gt;&gt;&gt; pyboy.memory[0xC000] =3D 1 # Write to address 0xC000 w=
ith value 1
        ```

        """</span>

        self.register_file =3D PyBoyRegisterFile(self.mb.cpu)
        <span class=3D"hljs-string">"""
        Provides a `pyboy.PyBoyRegisterFile` object for reading and writing=
 the CPU registers of the Game Boy.

        The register file is best used inside the callback of a hook, as `P=
yBoy.tick` doesn't return at a specific point.

        For a more comprehensive description, see the `pyboy.PyBoyRegisterF=
ile` class.

        Example:
        ```python
        &gt;&gt;&gt; def my_callback(register_file):
        ...     print("Register A:", register_file.A)
        &gt;&gt;&gt; pyboy.hook_register(0, 0x100, my_callback, pyboy.regis=
ter_file)
        &gt;&gt;&gt; pyboy.tick(70)
        Register A: 1
        True
        ```
        """</span>

        self.memory_scanner =3D MemoryScanner(self)
        <span class=3D"hljs-string">"""
        Provides a `pyboy.api.memory_scanner.MemoryScanner` object for loca=
ting addresses of interest in the memory space
        of the Game Boy. This might require some trial and error. Values ca=
n be represented in memory in surprising ways.

        _Open an issue on GitHub if you need finer control, and we will tak=
e a look at it._

        Example:
        ```python
        &gt;&gt;&gt; current_score =3D 4 # You write current score in game
        &gt;&gt;&gt; pyboy.memory_scanner.scan_memory(current_score, start_=
addr=3D0xC000, end_addr=3D0xDFFF)
        []
        &gt;&gt;&gt; for _ in range(175):
        ...     pyboy.tick(1, True) # Progress the game to change score
        True...
        &gt;&gt;&gt; current_score =3D 8 # You write the new score in game
        &gt;&gt;&gt; from pyboy.api.memory_scanner import DynamicComparison=
Type
        &gt;&gt;&gt; addresses =3D pyboy.memory_scanner.rescan_memory(curre=
nt_score, DynamicComparisonType.MATCH)
        &gt;&gt;&gt; print(addresses) # If repeated enough, only one addres=
s will remain
        []

        ```
        """</span>

        self.tilemap_background =3D TileMap(self, self.mb, <span class=3D"h=
ljs-string">"BACKGROUND"</span>)
        <span class=3D"hljs-string">"""
        The Game Boy uses two tile maps at the same time to draw graphics o=
n the screen. This method will provide one
        for the _background_ tiles. The game chooses whether it wants to us=
e the low or the high tilemap.

        Read more details about it, in the [Pan Docs](https://gbdev.io/pand=
ocs/Tile_Maps.html).

        Example:
        ```
        &gt;&gt;&gt; pyboy.tilemap_background[8,8]
        1
        &gt;&gt;&gt; pyboy.tilemap_background[7:12,8]
        [0, 1, 0, 1, 0]
        &gt;&gt;&gt; pyboy.tilemap_background[7:12,8:11]
        [[0, 1, 0, 1, 0], [0, 2, 3, 4, 5], [0, 0, 6, 0, 0]]

        ```

        Returns
        -------
        `pyboy.api.tilemap.TileMap`:
            A TileMap object for the tile map.
        """</span>

        self.tilemap_window =3D TileMap(self, self.mb, <span class=3D"hljs-=
string">"WINDOW"</span>)
        <span class=3D"hljs-string">"""
        The Game Boy uses two tile maps at the same time to draw graphics o=
n the screen. This method will provide one
        for the _window_ tiles. The game chooses whether it wants to use th=
e low or the high tilemap.

        Read more details about it, in the [Pan Docs](https://gbdev.io/pand=
ocs/Tile_Maps.html).

        Example:
        ```
        &gt;&gt;&gt; pyboy.tilemap_window[8,8]
        1
        &gt;&gt;&gt; pyboy.tilemap_window[7:12,8]
        [0, 1, 0, 1, 0]
        &gt;&gt;&gt; pyboy.tilemap_window[7:12,8:11]
        [[0, 1, 0, 1, 0], [0, 2, 3, 4, 5], [0, 0, 6, 0, 0]]

        ```

        Returns
        -------
        `pyboy.api.tilemap.TileMap`:
            A TileMap object for the tile map.
        """</span>

        self.cartridge_title =3D self.mb.cartridge.gamename
        <span class=3D"hljs-string">"""
        The title stored on the currently loaded cartridge ROM. The title i=
s all upper-case ASCII and may
        have been truncated to 11 characters.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.cartridge_title # Title of PyBoy's default ROM
        'DEFAULT-ROM'

        ```

        Returns
        -------
        str :
            Game title
        """</span>

        self._hooks =3D {}

        self._plugin_manager =3D PluginManager(self, self.mb, kwargs)
        <span class=3D"hljs-string">"""
        Returns
        -------
        `pyboy.plugins.manager.PluginManager`:
            Object for handling plugins in PyBoy
        """</span>

        self.game_wrapper =3D self._plugin_manager.gamewrapper()
        <span class=3D"hljs-string">"""
        Provides an instance of a game-specific or generic wrapper. The gam=
e is detected by the cartridge's hard-coded
        game title (see `pyboy.PyBoy.cartridge_title`).

        If a game-specific wrapper is not found, a generic wrapper will be =
returned.

        To get more information, find the wrapper for your game in `pyboy.p=
lugins`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.game_wrapper.start_game()
        &gt;&gt;&gt; pyboy.game_wrapper.reset_game()

        ```

        Returns
        -------
        `pyboy.plugins.base_plugin.PyBoyGameWrapper`:
            A game-specific wrapper object.
        """</span>

        self.initialized =3D <span class=3D"hljs-keyword">True</span>

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_tick</span><span class=3D"hljs-params">(self, re=
nder)</span>:</span>
        <span class=3D"hljs-keyword">if</span> self.stopped:
            <span class=3D"hljs-keyword">return</span> <span class=3D"hljs-=
keyword">False</span>

        t_start =3D time.perf_counter_ns()
        self._handle_events(self.events)
        t_pre =3D time.perf_counter_ns()
        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword"=
>not</span> self.paused:
            self.__rendering(render)
            <span class=3D"hljs-comment"># Reenter mb.tick until we eventua=
lly get a clean exit without breakpoints</span>
            <span class=3D"hljs-keyword">while</span> self.mb.tick():
                <span class=3D"hljs-comment"># Breakpoint reached</span>
                <span class=3D"hljs-comment"># <span class=3D"hljs-doctag">=
NOTE:</span> Potentially reinject breakpoint that we have now stepped passe=
d</span>
                self.mb.breakpoint_reinject()

                <span class=3D"hljs-comment"># <span class=3D"hljs-doctag">=
NOTE:</span> PC has not been incremented when hitting breakpoint!</span>
                breakpoint_meta =3D self.mb.breakpoint_reached()
                <span class=3D"hljs-keyword">if</span> breakpoint_meta !=3D=
 (<span class=3D"hljs-number">-1</span>, <span class=3D"hljs-number">-1</sp=
an>, <span class=3D"hljs-number">-1</span>):
                    bank, addr, _ =3D breakpoint_meta
                    self.mb.breakpoint_remove(bank, addr)
                    self.mb.breakpoint_singlestep_latch =3D <span class=3D"=
hljs-number">0</span>

                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> self._handle_hooks():
                        self._plugin_manager.handle_breakpoint()
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">if</span> self.mb.breakpoi=
nt_singlestep_latch:
                        <span class=3D"hljs-keyword">if</span> <span class=
=3D"hljs-keyword">not</span> self._handle_hooks():
                            self._plugin_manager.handle_breakpoint()
                    <span class=3D"hljs-comment"># Keep singlestepping on, =
if that's what we're doing</span>
                    self.mb.breakpoint_singlestep =3D self.mb.breakpoint_si=
nglestep_latch

            self.frame_count +=3D <span class=3D"hljs-number">1</span>
        t_tick =3D time.perf_counter_ns()
        self._post_tick()
        t_post =3D time.perf_counter_ns()

        nsecs =3D t_pre - t_start
        self.avg_pre =3D <span class=3D"hljs-number">0.9</span> * self.avg_=
pre + (<span class=3D"hljs-number">0.1</span>*nsecs/<span class=3D"hljs-num=
ber">1</span>_000_000_000)

        nsecs =3D t_tick - t_pre
        self.avg_tick =3D <span class=3D"hljs-number">0.9</span> * self.avg=
_tick + (<span class=3D"hljs-number">0.1</span>*nsecs/<span class=3D"hljs-n=
umber">1</span>_000_000_000)

        nsecs =3D t_post - t_tick
        self.avg_post =3D <span class=3D"hljs-number">0.9</span> * self.avg=
_post + (<span class=3D"hljs-number">0.1</span>*nsecs/<span class=3D"hljs-n=
umber">1</span>_000_000_000)

        <span class=3D"hljs-keyword">return</span> <span class=3D"hljs-keyw=
ord">not</span> self.quitting

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">tick</span><span class=3D"hljs-params">(self, cou=
nt=3D<span class=3D"hljs-number">1</span>, render=3DTrue)</span>:</span>
        <span class=3D"hljs-string">"""
        Progresses the emulator ahead by `count` frame(s).

        To run the emulator in real-time, it will need to process 60 frames=
 a second (for example in a while-loop).
        This function will block for roughly 16,67ms per frame, to not run =
faster than real-time, unless you specify
        otherwise with the `PyBoy.set_emulation_speed` method.

        If you need finer control than 1 frame, have a look at `PyBoy.hook_=
register` to inject code at a specific point
        in the game.

        Setting `render` to `True` will make PyBoy render the screen for *t=
he last frame* of this tick. This can be seen
        as a type of "frameskipping" optimization.

        For AI training, it's adviced to use as high a count as practical, =
as it will otherwise reduce performance
        substantially. While setting `render` to `False`, you can still acc=
ess the `PyBoy.game_area` to get a simpler
        representation of the game.

        If `render` was enabled, use `pyboy.api.screen.Screen` to get a Num=
Py buffer or raw memory buffer.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.tick() # Progress 1 frame with rendering
        True
        &gt;&gt;&gt; pyboy.tick(1) # Progress 1 frame with rendering
        True
        &gt;&gt;&gt; pyboy.tick(60, False) # Progress 60 frames *without* r=
endering
        True
        &gt;&gt;&gt; pyboy.tick(60, True) # Progress 60 frames and render *=
only the last frame*
        True
        &gt;&gt;&gt; for _ in range(60): # Progress 60 frames and render ev=
ery frame
        ...     if not pyboy.tick(1, True):
        ...         break
        &gt;&gt;&gt;
        ```

        Args:
            count (int): Number of ticks to process
            render (bool): Whether to render an image for this tick
        Returns
        -------
        (True or False):
            False if emulation has ended otherwise True
        """</span>

        running =3D <span class=3D"hljs-keyword">False</span>
        <span class=3D"hljs-keyword">while</span> count !=3D <span class=3D=
"hljs-number">0</span>:
            _render =3D render <span class=3D"hljs-keyword">and</span> coun=
t =3D=3D <span class=3D"hljs-number">1</span> <span class=3D"hljs-comment">=
# Only render on last tick to improve performance</span>
            running =3D self._tick(_render)
            count -=3D <span class=3D"hljs-number">1</span>
        <span class=3D"hljs-keyword">return</span> running

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_handle_events</span><span class=3D"hljs-params">=
(self, events)</span>:</span>
        <span class=3D"hljs-comment"># This feeds events into the tick-loop=
 from the window. There might already be events in the list from the API.</=
span>
        events =3D self._plugin_manager.handle_events(events)
        <span class=3D"hljs-keyword">for</span> event <span class=3D"hljs-k=
eyword">in</span> events:
            <span class=3D"hljs-keyword">if</span> event =3D=3D WindowEvent=
.QUIT:
                self.quitting =3D <span class=3D"hljs-keyword">True</span>
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.RELEASE_SPEED_UP:
                <span class=3D"hljs-comment"># Switch between unlimited and=
 1x real-time emulation speed</span>
                self.target_emulationspeed =3D int(bool(self.target_emulati=
onspeed) ^ <span class=3D"hljs-keyword">True</span>)
                logger.debug(<span class=3D"hljs-string">"Speed limit: %d"<=
/span>, self.target_emulationspeed)
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.STATE_SAVE:
                <span class=3D"hljs-keyword">with</span> open(self.gamerom =
+ <span class=3D"hljs-string">".state"</span>, <span class=3D"hljs-string">=
"wb"</span>) <span class=3D"hljs-keyword">as</span> f:
                    self.mb.save_state(IntIOWrapper(f))
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.STATE_LOAD:
                state_path =3D self.gamerom + <span class=3D"hljs-string">"=
.state"</span>
                <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-=
keyword">not</span> os.path.isfile(state_path):
                    logger.error(<span class=3D"hljs-string">"State file no=
t found: %s"</span>, state_path)
                    <span class=3D"hljs-keyword">continue</span>
                <span class=3D"hljs-keyword">with</span> open(state_path, <=
span class=3D"hljs-string">"rb"</span>) <span class=3D"hljs-keyword">as</sp=
an> f:
                    self.mb.load_state(IntIOWrapper(f))
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.PASS:
                <span class=3D"hljs-keyword">pass</span> <span class=3D"hlj=
s-comment"># Used in place of None in Cython, when key isn't mapped to anyt=
hing</span>
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.PAUSE_TOGGLE:
                <span class=3D"hljs-keyword">if</span> self.paused:
                    self._unpause()
                <span class=3D"hljs-keyword">else</span>:
                    self._pause()
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.PAUSE:
                self._pause()
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt.UNPAUSE:
                self._unpause()
            <span class=3D"hljs-keyword">elif</span> event =3D=3D WindowEve=
nt._INTERNAL_RENDERER_FLUSH:
                self._plugin_manager._post_tick_windows()
            <span class=3D"hljs-keyword">else</span>:
                self.mb.buttonevent(event)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_pause</span><span class=3D"hljs-params">(self)</=
span>:</span>
        <span class=3D"hljs-keyword">if</span> self.paused:
            <span class=3D"hljs-keyword">return</span>
        self.paused =3D <span class=3D"hljs-keyword">True</span>
        self.save_target_emulationspeed =3D self.target_emulationspeed
        self.target_emulationspeed =3D <span class=3D"hljs-number">1</span>
        logger.info(<span class=3D"hljs-string">"Emulation paused!"</span>)
        self._update_window_title()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_unpause</span><span class=3D"hljs-params">(self)=
</span>:</span>
        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword"=
>not</span> self.paused:
            <span class=3D"hljs-keyword">return</span>
        self.paused =3D <span class=3D"hljs-keyword">False</span>
        self.target_emulationspeed =3D self.save_target_emulationspeed
        logger.info(<span class=3D"hljs-string">"Emulation unpaused!"</span=
>)
        self._update_window_title()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_post_tick</span><span class=3D"hljs-params">(sel=
f)</span>:</span>
        <span class=3D"hljs-comment"># Fix buggy PIL. They will copy our im=
age buffer and destroy the</span>
        <span class=3D"hljs-comment"># reference on some user operations li=
ke .save().</span>
        <span class=3D"hljs-keyword">if</span> self.screen.image <span clas=
s=3D"hljs-keyword">and</span> <span class=3D"hljs-keyword">not</span> self.=
screen.image.readonly:
            self.screen._set_image()

        <span class=3D"hljs-keyword">if</span> self.frame_count % <span cla=
ss=3D"hljs-number">60</span> =3D=3D <span class=3D"hljs-number">0</span>:
            self._update_window_title()
        self._plugin_manager.post_tick()
        self._plugin_manager.frame_limiter(self.target_emulationspeed)

        <span class=3D"hljs-comment"># Prepare an empty list, as the API mi=
ght be used to send in events between ticks</span>
        self.events =3D []
        <span class=3D"hljs-keyword">while</span> self.queued_input <span c=
lass=3D"hljs-keyword">and</span> self.frame_count =3D=3D self.queued_input[=
<span class=3D"hljs-number">0</span>][<span class=3D"hljs-number">0</span>]=
:
            _, _event =3D heapq.heappop(self.queued_input)
            self.events.append(WindowEvent(_event))

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_update_window_title</span><span class=3D"hljs-pa=
rams">(self)</span>:</span>
        avg_emu =3D self.avg_pre + self.avg_tick + self.avg_post
        self.window_title =3D <span class=3D"hljs-string">f"CPU/frame: <spa=
n class=3D"hljs-subst">{(self.avg_pre + self.avg_tick) / SPF * <span class=
=3D"hljs-number">100</span>:<span class=3D"hljs-number">0.2</span>f}</span>=
%"</span>
        self.window_title +=3D <span class=3D"hljs-string">f' Emulation: x<=
span class=3D"hljs-subst">{(round(SPF / avg_emu) <span class=3D"hljs-keywor=
d">if</span> avg_emu &gt; <span class=3D"hljs-number">0</span> <span class=
=3D"hljs-keyword">else</span> <span class=3D"hljs-string">"INF"</span>)}</s=
pan>'</span>
        <span class=3D"hljs-keyword">if</span> self.paused:
            self.window_title +=3D <span class=3D"hljs-string">"[PAUSED]"</=
span>
        self.window_title +=3D self._plugin_manager.window_title()
        self._plugin_manager._set_title()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__del__</span><span class=3D"hljs-params">(self)<=
/span>:</span>
        self.stop(save=3D<span class=3D"hljs-keyword">False</span>)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__enter__</span><span class=3D"hljs-params">(self=
)</span>:</span>
        <span class=3D"hljs-keyword">return</span> self

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__exit__</span><span class=3D"hljs-params">(self,=
 type, value, traceback)</span>:</span>
        self.stop()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">stop</span><span class=3D"hljs-params">(self, sav=
e=3DTrue)</span>:</span>
        <span class=3D"hljs-string">"""
        Gently stops the emulator and all sub-modules.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.stop() # Stop emulator and save game progress (c=
artridge RAM)
        &gt;&gt;&gt; pyboy.stop(False) # Stop emulator and discard game pro=
gress (cartridge RAM)

        ```

        Args:
            save (bool): Specify whether to save the game upon stopping. It=
 will always be saved in a file next to the
                provided game-ROM.
        """</span>
        <span class=3D"hljs-keyword">if</span> self.initialized <span class=
=3D"hljs-keyword">and</span> <span class=3D"hljs-keyword">not</span> self.s=
topped:
            logger.info(<span class=3D"hljs-string">"######################=
#####"</span>)
            logger.info(<span class=3D"hljs-string">"# Emulator is turning =
off #"</span>)
            logger.info(<span class=3D"hljs-string">"######################=
#####"</span>)
            self._plugin_manager.stop()
            self.mb.stop(save)
            self.stopped =3D <span class=3D"hljs-keyword">True</span>

    <span class=3D"hljs-comment">##########################################=
#########################</span>
    <span class=3D"hljs-comment"># Scripts and bot methods</span>
    <span class=3D"hljs-comment">#</span>

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">button</span><span class=3D"hljs-params">(self, i=
nput, delay=3D<span class=3D"hljs-number">1</span>)</span>:</span>
        <span class=3D"hljs-string">"""
        Send input to PyBoy in the form of "a", "b", "start", "select", "le=
ft", "right", "up" and "down".

        The button will automatically be released at the following call to =
`PyBoy.tick`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.button('a') # Press button 'a' and release after=
 `pyboy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' released
        True
        &gt;&gt;&gt; pyboy.button('a', 3) # Press button 'a' and release af=
ter 3 `pyboy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' released
        True
        ```

        Args:
            input (str): button to press
            delay (int, optional): Number of frames to delay the release. D=
efaults to 1
        """</span>
        input =3D input.lower()
        <span class=3D"hljs-keyword">if</span> input =3D=3D <span class=3D"=
hljs-string">"left"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_LEFT)
            self.send_input(WindowEvent.RELEASE_ARROW_LEFT, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"right"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
            self.send_input(WindowEvent.RELEASE_ARROW_RIGHT, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"up"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_UP)
            self.send_input(WindowEvent.RELEASE_ARROW_UP, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"down"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_DOWN)
            self.send_input(WindowEvent.RELEASE_ARROW_DOWN, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"a"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_A)
            self.send_input(WindowEvent.RELEASE_BUTTON_A, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"b"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_B)
            self.send_input(WindowEvent.RELEASE_BUTTON_B, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"start"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_START)
            self.send_input(WindowEvent.RELEASE_BUTTON_START, delay)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"select"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
            self.send_input(WindowEvent.RELEASE_BUTTON_SELECT, delay)
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"Unrecognized input:"</span>, input)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">button_press</span><span class=3D"hljs-params">(s=
elf, input)</span>:</span>
        <span class=3D"hljs-string">"""
        Send input to PyBoy in the form of "a", "b", "start", "select", "le=
ft", "right", "up" and "down".

        The button will remain press until explicitly released with `PyBoy.=
button_release` or `PyBoy.send_input`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.button_press('a') # Press button 'a' and keep pr=
essed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
        True
        &gt;&gt;&gt; pyboy.button_release('a') # Release button 'a' on next=
 call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' released
        True

        ```

        Args:
            input (str): button to press
        """</span>
        input =3D input.lower()

        <span class=3D"hljs-keyword">if</span> input =3D=3D <span class=3D"=
hljs-string">"left"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_LEFT)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"right"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"up"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_UP)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"down"</span>:
            self.send_input(WindowEvent.PRESS_ARROW_DOWN)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"a"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_A)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"b"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_B)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"start"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_START)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"select"</span>:
            self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"Unrecognized input"</span>)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">button_release</span><span class=3D"hljs-params">=
(self, input)</span>:</span>
        <span class=3D"hljs-string">"""
        Send input to PyBoy in the form of "a", "b", "start", "select", "le=
ft", "right", "up" and "down".

        This will release a button after a call to `PyBoy.button_press` or =
`PyBoy.send_input`.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.button_press('a') # Press button 'a' and keep pr=
essed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
        True
        &gt;&gt;&gt; pyboy.button_release('a') # Release button 'a' on next=
 call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' released
        True

        ```

        Args:
            input (str): button to release
        """</span>
        input =3D input.lower()
        <span class=3D"hljs-keyword">if</span> input =3D=3D <span class=3D"=
hljs-string">"left"</span>:
            self.send_input(WindowEvent.RELEASE_ARROW_LEFT)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"right"</span>:
            self.send_input(WindowEvent.RELEASE_ARROW_RIGHT)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"up"</span>:
            self.send_input(WindowEvent.RELEASE_ARROW_UP)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"down"</span>:
            self.send_input(WindowEvent.RELEASE_ARROW_DOWN)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"a"</span>:
            self.send_input(WindowEvent.RELEASE_BUTTON_A)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"b"</span>:
            self.send_input(WindowEvent.RELEASE_BUTTON_B)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"start"</span>:
            self.send_input(WindowEvent.RELEASE_BUTTON_START)
        <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=
=3D"hljs-string">"select"</span>:
            self.send_input(WindowEvent.RELEASE_BUTTON_SELECT)
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"Unrecognized input"</span>)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">send_input</span><span class=3D"hljs-params">(sel=
f, event, delay=3D<span class=3D"hljs-number">0</span>)</span>:</span>
        <span class=3D"hljs-string">"""
        Send a single input to control the emulator. This is both Game Boy =
buttons and emulator controls. See
        `pyboy.utils.WindowEvent` for which events to send.

        Consider using `PyBoy.button` instead for easier access.

        Example:
        ```python
        &gt;&gt;&gt; from pyboy.utils import WindowEvent
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press b=
utton 'a' and keep pressed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
        True
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A) # Relea=
se button 'a' on next call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' released
        True
        ```

        And even simpler with delay:
        ```python
        &gt;&gt;&gt; from pyboy.utils import WindowEvent
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press b=
utton 'a' and keep pressed after `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A, 2) # Re=
lease button 'a' on third call to `PyBoy.tick()`
        &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
        True
        &gt;&gt;&gt; pyboy.tick() # Button 'a' released
        True
        ```

        Args:
            event (pyboy.WindowEvent): The event to send
            delay (int): 0 for immediately, number of frames to delay the i=
nput
        """</span>

        <span class=3D"hljs-keyword">if</span> delay:
            <span class=3D"hljs-keyword">assert</span> delay &gt; <span cla=
ss=3D"hljs-number">0</span>, <span class=3D"hljs-string">"Only positive int=
egers allowed"</span>
            heapq.heappush(self.queued_input, (self.frame_count + delay, ev=
ent))
        <span class=3D"hljs-keyword">else</span>:
            self.events.append(WindowEvent(event))

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">save_state</span><span class=3D"hljs-params">(sel=
f, file_like_object)</span>:</span>
        <span class=3D"hljs-string">"""
        Saves the complete state of the emulator. It can be called at any t=
ime, and enable you to revert any progress in
        a game.

        You can either save it to a file, or in-memory. The following two e=
xamples will provide the file handle in each
        case. Remember to `seek` the in-memory buffer to the beginning befo=
re calling `PyBoy.load_state`:

        ```python
        &gt;&gt;&gt; # Save to file
        &gt;&gt;&gt; with open("state_file.state", "wb") as f:
        ...     pyboy.save_state(f)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Save to memory
        &gt;&gt;&gt; import io
        &gt;&gt;&gt; with io.BytesIO() as f:
        ...     f.seek(0)
        ...     pyboy.save_state(f)
        0

        ```

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for wh=
ich to write the emulator state.
        """</span>

        <span class=3D"hljs-keyword">if</span> isinstance(file_like_object,=
 str):
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"String not allowed. Did you specify a filepath instead of=
 a file-like object?"</span>)

        <span class=3D"hljs-keyword">if</span> file_like_object.__class__._=
_name__ =3D=3D <span class=3D"hljs-string">"TextIOWrapper"</span>:
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"Text file not allowed. Did you specify open(..., 'wb')?"<=
/span>)

        self.mb.save_state(IntIOWrapper(file_like_object))

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">load_state</span><span class=3D"hljs-params">(sel=
f, file_like_object)</span>:</span>
        <span class=3D"hljs-string">"""
        Restores the complete state of the emulator. It can be called at an=
y time, and enable you to revert any progress
        in a game.

        You can either load it from a file, or from memory. See `PyBoy.save=
_state` for how to save the state, before you
        can load it here.

        To load a file, remember to load it as bytes:
        ```python
        &gt;&gt;&gt; # Load file
        &gt;&gt;&gt; with open("state_file.state", "rb") as f:
        ...     pyboy.load_state(f)
        &gt;&gt;&gt;
        ```

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for wh=
ich to read the emulator state.
        """</span>

        <span class=3D"hljs-keyword">if</span> isinstance(file_like_object,=
 str):
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"String not allowed. Did you specify a filepath instead of=
 a file-like object?"</span>)

        <span class=3D"hljs-keyword">if</span> file_like_object.__class__._=
_name__ =3D=3D <span class=3D"hljs-string">"TextIOWrapper"</span>:
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"Text file not allowed. Did you specify open(..., 'rb')?"<=
/span>)

        self.mb.load_state(IntIOWrapper(file_like_object))

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">game_area_dimensions</span><span class=3D"hljs-pa=
rams">(self, x, y, width, height, follow_scrolling=3DTrue)</span>:</span>
        <span class=3D"hljs-string">"""
        If using the generic game wrapper (see `pyboy.PyBoy.game_wrapper`),=
 you can use this to set the section of the
        tilemaps to extract. This will default to the entire tilemap.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.game_wrapper.shape
        (32, 32)
        &gt;&gt;&gt; pyboy.game_area_dimensions(2, 2, 10, 18, False)
        &gt;&gt;&gt; pyboy.game_wrapper.shape
        (10, 18)
        ```

        Args:
            x (int): Offset from top-left corner of the screen
            y (int): Offset from top-left corner of the screen
            width (int): Width of game area
            height (int): Height of game area
            follow_scrolling (bool): Whether to follow the scrolling of [SC=
X and SCY](https://gbdev.io/pandocs/Scrolling.html)
        """</span>
        self.game_wrapper._set_dimensions(x, y, width, height, follow_scrol=
ling=3D<span class=3D"hljs-keyword">True</span>)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">game_area_collision</span><span class=3D"hljs-par=
ams">(self)</span>:</span>
        <span class=3D"hljs-string">"""
        Some game wrappers define a collision map. Check if your game wrapp=
er has this feature implemented: `pyboy.plugins`.

        The output will be unique for each game wrapper.

        Example:
        ```python
        &gt;&gt;&gt; # This example show nothing, but a supported game will
        &gt;&gt;&gt; pyboy.game_area_collision()
        array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=3Duint32)

        ```

        Returns
        -------
        memoryview:
            Simplified 2-dimensional memoryview of the collision map
        """</span>
        <span class=3D"hljs-keyword">return</span> self.game_wrapper.game_a=
rea_collision()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">game_area_mapping</span><span class=3D"hljs-param=
s">(self, mapping, sprite_offset=3D<span class=3D"hljs-number">0</span>)</s=
pan>:</span>
        <span class=3D"hljs-string">"""
        Define custom mappings for tile identifiers in the game area.

        Example of custom mapping:
        ```python
        &gt;&gt;&gt; mapping =3D [x for x in range(384)] # 1:1 mapping
        &gt;&gt;&gt; mapping[0] =3D 0 # Map tile identifier 0 -&gt; 0
        &gt;&gt;&gt; mapping[1] =3D 0 # Map tile identifier 1 -&gt; 0
        &gt;&gt;&gt; mapping[2] =3D 0 # Map tile identifier 2 -&gt; 0
        &gt;&gt;&gt; mapping[3] =3D 0 # Map tile identifier 3 -&gt; 0
        &gt;&gt;&gt; pyboy.game_area_mapping(mapping, 1000)

        ```

        Some game wrappers will supply mappings as well. See the specific d=
ocumentation for your game wrapper:
        `pyboy.plugins`.
        ```python
        &gt;&gt;&gt; pyboy.game_area_mapping(pyboy.game_wrapper.mapping_one=
_to_one, 0)

        ```

        Args:
            mapping (list or ndarray): list of 384 (DMG) or 768 (CGB) tile =
mappings. Use `None` to reset to a 1:1 mapping.
            sprite_offest (int): Optional offset add to tile id for sprites
        """</span>

        <span class=3D"hljs-keyword">if</span> mapping <span class=3D"hljs-=
keyword">is</span> <span class=3D"hljs-keyword">None</span>:
            mapping =3D [x <span class=3D"hljs-keyword">for</span> x <span =
class=3D"hljs-keyword">in</span> range(<span class=3D"hljs-number">768</spa=
n>)]

        <span class=3D"hljs-keyword">assert</span> isinstance(sprite_offset=
, int)
        <span class=3D"hljs-keyword">assert</span> isinstance(mapping, (np.=
ndarray, list))
        <span class=3D"hljs-keyword">assert</span> len(mapping) =3D=3D <spa=
n class=3D"hljs-number">384</span> <span class=3D"hljs-keyword">or</span> l=
en(mapping) =3D=3D <span class=3D"hljs-number">768</span>

        self.game_wrapper.game_area_mapping(mapping, sprite_offset)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">game_area</span><span class=3D"hljs-params">(self=
)</span>:</span>
        <span class=3D"hljs-string">"""
        Use this method to get a matrix of the "game area" of the screen. T=
his view is simplified to be perfect for
        machine learning applications.

        The layout will vary from game to game. Below is an example from Te=
tris:

        Example:
        ```python
        &gt;&gt;&gt; pyboy.game_area()
        array([[ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47, 130, 130,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47, 130, 130,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
               [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47]], dtype=
=3Duint32)

        ```

        If you want a "compressed", "minimal" or raw mapping of tiles, you =
can change the mapping using
        `pyboy.PyBoy.game_area_mapping`. Either you'll have to supply your =
own mapping, or you can find one
        that is built-in with the game wrapper plugin for your game. See `p=
yboy.PyBoy.game_area_mapping`.

        Returns
        -------
        memoryview:
            Simplified 2-dimensional memoryview of the screen
        """</span>

        <span class=3D"hljs-keyword">return</span> self.game_wrapper.game_a=
rea()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_serial</span><span class=3D"hljs-params">(self)<=
/span>:</span>
        <span class=3D"hljs-string">"""
        Provides all data that has been sent over the serial port since las=
t call to this function.

        Returns
        -------
        str :
            Buffer data
        """</span>
        <span class=3D"hljs-keyword">return</span> self.mb.getserial()

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">set_emulation_speed</span><span class=3D"hljs-par=
ams">(self, target_speed)</span>:</span>
        <span class=3D"hljs-string">"""
        Set the target emulation speed. It might loose accuracy of keeping =
the exact speed, when using a high
        `target_speed`.

        The speed is defined as a multiple of real-time. I.e `target_speed=
=3D2` is double speed.

        A `target_speed` of `0` means unlimited. I.e. fastest possible exec=
ution.

        Some window types do not implement a frame-limiter, and will always=
 run at full speed.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.tick() # Delays 16.67ms
        True
        &gt;&gt;&gt; pyboy.set_emulation_speed(0) # Disable limit
        &gt;&gt;&gt; pyboy.tick() # As fast as possible
        True
        ```

        Args:
            target_speed (int): Target emulation speed as multiplier of rea=
l-time.
        """</span>
        <span class=3D"hljs-keyword">if</span> self.initialized <span class=
=3D"hljs-keyword">and</span> self._plugin_manager.window_null_enabled:
            logger.warning(
                <span class=3D"hljs-string">'This window type does not supp=
ort frame-limiting. `pyboy.set_emulation_speed(...)` will have no effect, a=
s it\'s always running at full speed.'</span>
            )

        <span class=3D"hljs-keyword">if</span> target_speed &gt; <span clas=
s=3D"hljs-number">5</span>:
            logger.warning(<span class=3D"hljs-string">"The emulation speed=
 might not be accurate when speed-target is higher than 5"</span>)
        self.target_emulationspeed =3D target_speed

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__rendering</span><span class=3D"hljs-params">(se=
lf, value)</span>:</span>
        <span class=3D"hljs-string">"""
        Disable or enable rendering
        """</span>
        self.mb.lcd.disable_renderer =3D <span class=3D"hljs-keyword">not</=
span> value

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_is_cpu_stuck</span><span class=3D"hljs-params">(=
self)</span>:</span>
        <span class=3D"hljs-keyword">return</span> self.mb.cpu.is_stuck

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_load_symbols</span><span class=3D"hljs-params">(=
self)</span>:</span>
        gamerom_file_no_ext, rom_ext =3D os.path.splitext(self.gamerom)
        <span class=3D"hljs-keyword">for</span> sym_path <span class=3D"hlj=
s-keyword">in</span> [self.symbols_file, gamerom_file_no_ext + <span class=
=3D"hljs-string">".sym"</span>, gamerom_file_no_ext + rom_ext + <span class=
=3D"hljs-string">".sym"</span>]:
            <span class=3D"hljs-keyword">if</span> sym_path <span class=3D"=
hljs-keyword">and</span> os.path.isfile(sym_path):
                logger.info(<span class=3D"hljs-string">"Loading symbol fil=
e: %s"</span>, sym_path)
                <span class=3D"hljs-keyword">with</span> open(sym_path) <sp=
an class=3D"hljs-keyword">as</span> f:
                    <span class=3D"hljs-keyword">for</span> _line <span cla=
ss=3D"hljs-keyword">in</span> f.readlines():
                        line =3D _line.strip()
                        <span class=3D"hljs-keyword">if</span> line =3D=3D =
<span class=3D"hljs-string">""</span>:
                            <span class=3D"hljs-keyword">continue</span>
                        <span class=3D"hljs-keyword">elif</span> line.start=
swith(<span class=3D"hljs-string">";"</span>):
                            <span class=3D"hljs-keyword">continue</span>
                        <span class=3D"hljs-keyword">elif</span> line.start=
swith(<span class=3D"hljs-string">"["</span>):
                            <span class=3D"hljs-comment"># Start of key gro=
up</span>
                            <span class=3D"hljs-comment"># [labels]</span>
                            <span class=3D"hljs-comment"># [definitions]</s=
pan>
                            <span class=3D"hljs-keyword">continue</span>

                        <span class=3D"hljs-keyword">try</span>:
                            bank, addr, sym_label =3D re.split(<span class=
=3D"hljs-string">":| "</span>, line.strip())
                            bank =3D int(bank, <span class=3D"hljs-number">=
16</span>)
                            addr =3D int(addr, <span class=3D"hljs-number">=
16</span>)
                            <span class=3D"hljs-keyword">if</span> <span cl=
ass=3D"hljs-keyword">not</span> bank <span class=3D"hljs-keyword">in</span>=
 self.rom_symbols:
                                self.rom_symbols[bank] =3D {}

                            <span class=3D"hljs-keyword">if</span> <span cl=
ass=3D"hljs-keyword">not</span> addr <span class=3D"hljs-keyword">in</span>=
 self.rom_symbols[bank]:
                                self.rom_symbols[bank][addr] =3D []

                            self.rom_symbols[bank][addr].append(sym_label)
                            self.rom_symbols_inverse[sym_label] =3D (bank, =
addr)
                        <span class=3D"hljs-keyword">except</span> ValueErr=
or <span class=3D"hljs-keyword">as</span> ex:
                            logger.warning(<span class=3D"hljs-string">"Ski=
pping .sym line: %s"</span>, line.strip())
        <span class=3D"hljs-keyword">return</span> self.rom_symbols

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_lookup_symbol</span><span class=3D"hljs-params">=
(self, symbol)</span>:</span>
        bank_addr =3D self.rom_symbols_inverse.get(symbol)
        <span class=3D"hljs-keyword">if</span> bank_addr <span class=3D"hlj=
s-keyword">is</span> <span class=3D"hljs-keyword">None</span>:
            <span class=3D"hljs-keyword">raise</span> ValueError(<span clas=
s=3D"hljs-string">"Symbol not found: %s"</span> % symbol)
        <span class=3D"hljs-keyword">return</span> bank_addr

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">symbol_lookup</span><span class=3D"hljs-params">(=
self, symbol)</span>:</span>
        <span class=3D"hljs-string">"""
        Look up a specific symbol from provided symbols file.

        This can be useful in combination with `PyBoy.memory` or even `PyBo=
y.hook_register`.

        See `PyBoy.hook_register` for how to load symbol into PyBoy.

        Example:
        ```python
        &gt;&gt;&gt; # Directly
        &gt;&gt;&gt; pyboy.memory[pyboy.symbol_lookup("Tileset")]
        0
        &gt;&gt;&gt; # By bank and address
        &gt;&gt;&gt; bank, addr =3D pyboy.symbol_lookup("Tileset")
        &gt;&gt;&gt; pyboy.memory[bank, addr]
        0
        &gt;&gt;&gt; pyboy.memory[bank, addr:addr+10]
        [0, 0, 0, 0, 0, 0, 102, 102, 102, 102]

        ```
        Returns
        -------
        (int, int):
            ROM/RAM bank, address
        """</span>
        <span class=3D"hljs-keyword">return</span> self._lookup_symbol(symb=
ol)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">hook_register</span><span class=3D"hljs-params">(=
self, bank, addr, callback, context)</span>:</span>
        <span class=3D"hljs-string">"""
        Adds a hook into a specific bank and memory address.
        When the Game Boy executes this address, the provided callback func=
tion will be called.

        By providing an object as `context`, you can later get access to in=
formation inside and outside of the callback.

        Example:
        ```python
        &gt;&gt;&gt; context =3D "Hello from hook"
        &gt;&gt;&gt; def my_callback(context):
        ...     print(context)
        &gt;&gt;&gt; pyboy.hook_register(0, 0x100, my_callback, context)
        &gt;&gt;&gt; pyboy.tick(70)
        Hello from hook
        True

        ```

        If a symbol file is loaded, this function can also automatically re=
solve a bank and address from a symbol. To
        enable this, you'll need to place a `.sym` file next to your ROM, o=
r provide it using:
        `PyBoy(..., symbols=3D"game_rom.gb.sym")`.

        Then provide `None` for `bank` and the symbol for `addr` to trigger=
 the automatic lookup.

        Example:
        ```python
        &gt;&gt;&gt; # Continued example above
        &gt;&gt;&gt; pyboy.hook_register(None, "Main.move", lambda x: print=
(x), "Hello from hook2")
        &gt;&gt;&gt; pyboy.tick(80)
        Hello from hook2
        True

        ```

        **NOTE**:

        Don't register hooks to something that isn't executable (graphics d=
ata etc.). This will cause your game to show
        weird behavior or crash. Hooks are installed by replacing the instr=
uction at the bank and address with a special
        opcode (`0xDB`). If the address is read by the game instead of exec=
uted as code, this value will be read instead.

        Args:
            bank (int or None): ROM or RAM bank (None for symbol lookup)
            addr (int or str): Address in the Game Boy's address space (str=
 for symbol lookup)
            callback (func): A function which takes `context` as argument
            context (object): Argument to pass to callback when hook is cal=
led
        """</span>
        <span class=3D"hljs-keyword">if</span> bank <span class=3D"hljs-key=
word">is</span> <span class=3D"hljs-keyword">None</span> <span class=3D"hlj=
s-keyword">and</span> isinstance(addr, str):
            bank, addr =3D self._lookup_symbol(addr)

        opcode =3D self.memory[bank, addr]
        <span class=3D"hljs-keyword">if</span> opcode =3D=3D <span class=3D=
"hljs-number">0xDB</span>:
            <span class=3D"hljs-keyword">raise</span> ValueError(<span clas=
s=3D"hljs-string">"Hook already registered for this bank and address."</spa=
n>)
        self.mb.breakpoint_add(bank, addr)
        bank_addr_opcode =3D (bank &amp; <span class=3D"hljs-number">0xFF</=
span>) &lt;&lt; <span class=3D"hljs-number">24</span> | (addr &amp; <span c=
lass=3D"hljs-number">0xFFFF</span>) &lt;&lt; <span class=3D"hljs-number">8<=
/span> | (opcode &amp; <span class=3D"hljs-number">0xFF</span>)
        logger.debug(<span class=3D"hljs-string">"Adding hook for opcode %0=
8x"</span>, bank_addr_opcode)
        self._hooks[bank_addr_opcode] =3D (callback, context)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">hook_deregister</span><span class=3D"hljs-params"=
>(self, bank, addr)</span>:</span>
        <span class=3D"hljs-string">"""
        Remove a previously registered hook from a specific bank and memory=
 address.

        Example:
        ```python
        &gt;&gt;&gt; context =3D "Hello from hook"
        &gt;&gt;&gt; def my_callback(context):
        ...     print(context)
        &gt;&gt;&gt; pyboy.hook_register(0, 0x2000, my_callback, context)
        &gt;&gt;&gt; pyboy.hook_deregister(0, 0x2000)

        ```

        This function can also deregister a hook based on a symbol. See `Py=
Boy.hook_register` for details.

        Example:
        ```python
        &gt;&gt;&gt; pyboy.hook_register(None, "Main", lambda x: print(x), =
"Hello from hook")
        &gt;&gt;&gt; pyboy.hook_deregister(None, "Main")

        ```

        Args:
            bank (int or None): ROM or RAM bank (None for symbol lookup)
            addr (int or str): Address in the Game Boy's address space (str=
 for symbol lookup)
        """</span>
        <span class=3D"hljs-keyword">if</span> bank <span class=3D"hljs-key=
word">is</span> <span class=3D"hljs-keyword">None</span> <span class=3D"hlj=
s-keyword">and</span> isinstance(addr, str):
            bank, addr =3D self._lookup_symbol(addr)

        breakpoint_meta =3D self.mb.breakpoint_find(bank, addr)
        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword"=
>not</span> breakpoint_meta:
            <span class=3D"hljs-keyword">raise</span> ValueError(<span clas=
s=3D"hljs-string">"Breakpoint not found for bank and addr"</span>)
        _, _, opcode =3D breakpoint_meta

        self.mb.breakpoint_remove(bank, addr)
        bank_addr_opcode =3D (bank &amp; <span class=3D"hljs-number">0xFF</=
span>) &lt;&lt; <span class=3D"hljs-number">24</span> | (addr &amp; <span c=
lass=3D"hljs-number">0xFFFF</span>) &lt;&lt; <span class=3D"hljs-number">8<=
/span> | (opcode &amp; <span class=3D"hljs-number">0xFF</span>)
        self._hooks.pop(bank_addr_opcode)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_handle_hooks</span><span class=3D"hljs-params">(=
self)</span>:</span>
        <span class=3D"hljs-keyword">if</span> _handler :=3D self._hooks.ge=
t(self.mb.breakpoint_waiting):
            (callback, context) =3D _handler
            callback(context)
            <span class=3D"hljs-keyword">return</span> <span class=3D"hljs-=
keyword">True</span>
        <span class=3D"hljs-keyword">return</span> <span class=3D"hljs-keyw=
ord">False</span>

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">get_sprite</span><span class=3D"hljs-params">(sel=
f, sprite_index)</span>:</span>
        <span class=3D"hljs-string">"""
        Provides a `pyboy.api.sprite.Sprite` object, which makes the OAM da=
ta more presentable. The given index
        corresponds to index of the sprite in the "Object Attribute Memory"=
 (OAM).

        The Game Boy supports 40 sprites in total. Read more details about =
it, in the [Pan
        Docs](http://bgb.bircd.org/pandocs.htm).

        ```python
        &gt;&gt;&gt; s =3D pyboy.get_sprite(12)
        &gt;&gt;&gt; s
        Sprite [12]: Position: (-8, -16), Shape: (8, 8), Tiles: (Tile: 0), =
On screen: False
        &gt;&gt;&gt; s.on_screen
        False
        &gt;&gt;&gt; s.tiles
        [Tile: 0]

        ```

        Args:
            index (int): Sprite index from 0 to 39.
        Returns
        -------
        `pyboy.api.sprite.Sprite`:
            Sprite corresponding to the given index.
        """</span>
        <span class=3D"hljs-keyword">return</span> Sprite(self.mb, sprite_i=
ndex)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">get_sprite_by_tile_identifier</span><span class=
=3D"hljs-params">(self, tile_identifiers, on_screen=3DTrue)</span>:</span>
        <span class=3D"hljs-string">"""
        Provided a list of tile identifiers, this function will find all oc=
currences of sprites using the tile
        identifiers and return the sprite indexes where each identifier is =
found. Use the sprite indexes in the
        `pyboy.PyBoy.get_sprite` function to get a `pyboy.api.sprite.Sprite=
` object.

        Example:
        ```python
        &gt;&gt;&gt; print(pyboy.get_sprite_by_tile_identifier([43, 123]))
        [[0, 2, 4], []]

        ```

        Meaning, that tile identifier `43` is found at the sprite indexes: =
0, 2, and 4, while tile identifier
        `123` was not found anywhere.

        Args:
            identifiers (list): List of tile identifiers (int)
            on_screen (bool): Require that the matched sprite is on screen

        Returns
        -------
        list:
            list of sprite matches for every tile identifier in the input
        """</span>

        matches =3D []
        <span class=3D"hljs-keyword">for</span> i <span class=3D"hljs-keywo=
rd">in</span> tile_identifiers:
            match =3D []
            <span class=3D"hljs-keyword">for</span> s <span class=3D"hljs-k=
eyword">in</span> range(constants.SPRITES):
                sprite =3D Sprite(self.mb, s)
                <span class=3D"hljs-keyword">for</span> t <span class=3D"hl=
js-keyword">in</span> sprite.tiles:
                    <span class=3D"hljs-keyword">if</span> t.tile_identifie=
r =3D=3D i <span class=3D"hljs-keyword">and</span> (<span class=3D"hljs-key=
word">not</span> on_screen <span class=3D"hljs-keyword">or</span> (on_scree=
n <span class=3D"hljs-keyword">and</span> sprite.on_screen)):
                        match.append(s)
            matches.append(match)
        <span class=3D"hljs-keyword">return</span> matches

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">get_tile</span><span class=3D"hljs-params">(self,=
 identifier)</span>:</span>
        <span class=3D"hljs-string">"""
        The Game Boy can have 384 tiles loaded in memory at once (768 for G=
ame Boy Color). Use this method to get a
        `pyboy.api.tile.Tile`-object for given identifier.

        The identifier is a PyBoy construct, which unifies two different sc=
opes of indexes in the Game Boy hardware. See
        the `pyboy.api.tile.Tile` object for more information.

        Example:
        ```python
        &gt;&gt;&gt; t =3D pyboy.get_tile(2)
        &gt;&gt;&gt; t
        Tile: 2
        &gt;&gt;&gt; t.shape
        (8, 8)

        ```

        Returns
        -------
        `pyboy.api.tile.Tile`:
            A Tile object for the given identifier.
        """</span>
        <span class=3D"hljs-keyword">return</span> Tile(self.mb, identifier=
=3Didentifier)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">rtc_lock_experimental</span><span class=3D"hljs-p=
arams">(self, enable)</span>:</span>
        <span class=3D"hljs-string">"""
        **WARN: This is an experimental API and is subject to change.**

        Lock the Real Time Clock (RTC) of a supporting cartridge. It might =
be advantageous to lock the RTC when training
        an AI in games that use it to change behavior (i.e. day and night).

        The first time the game is turned on, an `.rtc` file is created wit=
h the current time. This is the epoch for the
        RTC. When using `rtc_lock_experimental`, the RTC will always report=
 this point in time. If you let the game
        progress first, before using `rtc_lock_experimental`, the internal =
clock will move backwards and might corrupt
        the game.

        Example:
        ```python
        &gt;&gt;&gt; pyboy =3D PyBoy('game_rom.gb')
        &gt;&gt;&gt; pyboy.rtc_lock_experimental(True) # RTC will not progr=
ess
        ```

        **WARN: This is an experimental API and is subject to change.**

        Args:
            enable (bool): True to lock RTC, False to operate normally
        """</span>
        <span class=3D"hljs-keyword">if</span> self.mb.cartridge.rtc_enable=
d:
            self.mb.cartridge.rtc.timelock =3D enable
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-keyword">raise</span> Exception(<span class=
=3D"hljs-string">"There's no RTC for this cartridge type"</span>)</code></p=
re>
</details>
<h3>Instance variables</h3>
<dl>
<dt id=3D"pyboy.PyBoy.screen"><code class=3D"name">var <span class=3D"ident=
">screen</span></code></dt>
<dd>
<section class=3D"desc"><p>Use this method to get a <code><a title=3D"pyboy=
.api.screen.Screen" href=3D"https://docs.pyboy.dk/api/screen.html#pyboy.api=
.screen.Screen">Screen</a></code> object. This can be used to get the scree=
n buffer in
a variety of formats.</p>
<p>It's also here you can find the screen position (SCX, SCY, WX, WY) for e=
ach scan line in the screen buffer. See
<code><a title=3D"pyboy.api.screen.Screen.tilemap_position_list" href=3D"ht=
tps://docs.pyboy.dk/api/screen.html#pyboy.api.screen.Screen.tilemap_positio=
n_list">Screen.tilemap_position_list</a></code> for more information.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.screen.image.show()
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.screen.ndarray.shape
(<span class=3D"hljs-number">144</span>, <span class=3D"hljs-number">160</s=
pan>, <span class=3D"hljs-number">4</span>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.screen.raw_buffer_forma=
t
<span class=3D"hljs-string">'RGBA'</span>

</code></pre>
<h2 id=3D"returns">Returns</h2>
<p><code><a title=3D"pyboy.api.screen.Screen" href=3D"https://docs.pyboy.dk=
/api/screen.html#pyboy.api.screen.Screen">Screen</a></code>:
A Screen object with helper functions for reading the screen buffer.</p></s=
ection>
</dd>
<dt id=3D"pyboy.PyBoy.memory"><code class=3D"name">var <span class=3D"ident=
">memory</span></code></dt>
<dd>
<section class=3D"desc"><p>Provides a <code><a title=3D"pyboy.PyBoyMemoryVi=
ew" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoyMemoryView">PyBoyMe=
moryView</a></code> object for reading and writing the memory space of the =
Game Boy.</p>
<p>For a more comprehensive description, see the <code><a title=3D"pyboy.Py=
BoyMemoryView" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoyMemoryVi=
ew">PyBoyMemoryView</a></code> class.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.memory[<span class=3D"hljs-number">0x0000</span>:<span c=
lass=3D"hljs-number">0x0010</span>] <span class=3D"hljs-comment"># Read 16 =
bytes from ROM bank 0</span>
[<span class=3D"hljs-number">49</span>, <span class=3D"hljs-number">254</sp=
an>, <span class=3D"hljs-number">255</span>, <span class=3D"hljs-number">33=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
128</span>, <span class=3D"hljs-number">175</span>, <span class=3D"hljs-num=
ber">34</span>, <span class=3D"hljs-number">124</span>, <span class=3D"hljs=
-number">254</span>, <span class=3D"hljs-number">160</span>, <span class=3D=
"hljs-number">32</span>, <span class=3D"hljs-number">249</span>, <span clas=
s=3D"hljs-number">6</span>, <span class=3D"hljs-number">48</span>, <span cl=
ass=3D"hljs-number">33</span>]
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">1</span>, <span class=3D"hljs-number">0x2000</span>] =3D <span =
class=3D"hljs-number">12</span> <span class=3D"hljs-comment"># Override add=
ress 0x2000 from ROM bank 1 with the value 12</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0xC000</span>] =3D <span class=3D"hljs-number">1</span> <span c=
lass=3D"hljs-comment"># Write to address 0xC000 with value 1</span>
</code></pre></section>
</dd>
<dt id=3D"pyboy.PyBoy.register_file"><code class=3D"name">var <span class=
=3D"ident">register_file</span></code></dt>
<dd>
<section class=3D"desc"><p>Provides a <code><a title=3D"pyboy.PyBoyRegister=
File" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoyRegisterFile">PyB=
oyRegisterFile</a></code> object for reading and writing the CPU registers =
of the Game Boy.</p>
<p>The register file is best used inside the callback of a hook, as <code><=
a title=3D"pyboy.PyBoy.tick" href=3D"https://docs.pyboy.dk/index.html#pyboy=
.PyBoy.tick">PyBoy.tick()</a></code> doesn't return at a specific point.</p=
>
<p>For a more comprehensive description, see the <code><a title=3D"pyboy.Py=
BoyRegisterFile" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoyRegist=
erFile">PyBoyRegisterFile</a></code> class.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-function"><span class=3D"hljs-keyword">def=
</span> <span class=3D"hljs-title">my_callback</span><span class=3D"hljs-pa=
rams">(register_file)</span>:</span>
<span class=3D"hljs-meta">... </span>    print(<span class=3D"hljs-string">=
"Register A:"</span>, register_file.A)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_register(<span cla=
ss=3D"hljs-number">0</span>, <span class=3D"hljs-number">0x100</span>, my_c=
allback, pyboy.register_file)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">70</span>)
Register A: <span class=3D"hljs-number">1</span>
<span class=3D"hljs-keyword">True</span>
</code></pre></section>
</dd>
<dt id=3D"pyboy.PyBoy.memory_scanner"><code class=3D"name">var <span class=
=3D"ident">memory_scanner</span></code></dt>
<dd>
<section class=3D"desc"><p>Provides a <code><a title=3D"pyboy.api.memory_sc=
anner.MemoryScanner" href=3D"https://docs.pyboy.dk/api/memory_scanner.html#=
pyboy.api.memory_scanner.MemoryScanner">MemoryScanner</a></code> object for=
 locating addresses of interest in the memory space
of the Game Boy. This might require some trial and error. Values can be rep=
resented in memory in surprising ways.</p>
<p><em>Open an issue on GitHub if you need finer control, and we will take =
a look at it.</em></p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>current_score =3D <span class=3D"hljs-number">4</span> <span c=
lass=3D"hljs-comment"># You write current score in game</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory_scanner.scan_mem=
ory(current_score, start_addr=3D<span class=3D"hljs-number">0xC000</span>, =
end_addr=3D<span class=3D"hljs-number">0xDFFF</span>)
[]
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
for</span> _ <span class=3D"hljs-keyword">in</span> range(<span class=3D"hl=
js-number">175</span>):
<span class=3D"hljs-meta">... </span>    pyboy.tick(<span class=3D"hljs-num=
ber">1</span>, <span class=3D"hljs-keyword">True</span>) <span class=3D"hlj=
s-comment"># Progress the game to change score</span>
<span class=3D"hljs-keyword">True</span>...
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>current_score =3D <span class=
=3D"hljs-number">8</span> <span class=3D"hljs-comment"># You write the new =
score in game</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
from</span> pyboy.api.memory_scanner <span class=3D"hljs-keyword">import</s=
pan> DynamicComparisonType
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>addresses =3D pyboy.memory_sc=
anner.rescan_memory(current_score, DynamicComparisonType.MATCH)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>print(addresses) <span class=
=3D"hljs-comment"># If repeated enough, only one address will remain</span>
[]

</code></pre></section>
</dd>
<dt id=3D"pyboy.PyBoy.tilemap_background"><code class=3D"name">var <span cl=
ass=3D"ident">tilemap_background</span></code></dt>
<dd>
<section class=3D"desc"><p>The Game Boy uses two tile maps at the same time=
 to draw graphics on the screen. This method will provide one
for the <em>background</em> tiles. The game chooses whether it wants to use=
 the low or the high tilemap.</p>
<p>Read more details about it, in the <a href=3D"https://gbdev.io/pandocs/T=
ile_Maps.html">Pan Docs</a>.</p>
<p>Example:</p>
<pre><code class=3D"hljs css">&gt;&gt;&gt; <span class=3D"hljs-selector-tag=
">pyboy</span><span class=3D"hljs-selector-class">.tilemap_background</span=
><span class=3D"hljs-selector-attr">[8,8]</span>
1
&gt;&gt;&gt; <span class=3D"hljs-selector-tag">pyboy</span><span class=3D"h=
ljs-selector-class">.tilemap_background</span><span class=3D"hljs-selector-=
attr">[7:12,8]</span>
<span class=3D"hljs-selector-attr">[0, 1, 0, 1, 0]</span>
&gt;&gt;&gt; <span class=3D"hljs-selector-tag">pyboy</span><span class=3D"h=
ljs-selector-class">.tilemap_background</span><span class=3D"hljs-selector-=
attr">[7:12,8:11]</span>
<span class=3D"hljs-selector-attr">[[0, 1, 0, 1, 0]</span>, <span class=3D"=
hljs-selector-attr">[0, 2, 3, 4, 5]</span>, <span class=3D"hljs-selector-at=
tr">[0, 0, 6, 0, 0]</span>]

</code></pre>
<h2 id=3D"returns">Returns</h2>
<p><code><a title=3D"pyboy.api.tilemap.TileMap" href=3D"https://docs.pyboy.=
dk/api/tilemap.html#pyboy.api.tilemap.TileMap">TileMap</a></code>:
A TileMap object for the tile map.</p></section>
</dd>
<dt id=3D"pyboy.PyBoy.tilemap_window"><code class=3D"name">var <span class=
=3D"ident">tilemap_window</span></code></dt>
<dd>
<section class=3D"desc"><p>The Game Boy uses two tile maps at the same time=
 to draw graphics on the screen. This method will provide one
for the <em>window</em> tiles. The game chooses whether it wants to use the=
 low or the high tilemap.</p>
<p>Read more details about it, in the <a href=3D"https://gbdev.io/pandocs/T=
ile_Maps.html">Pan Docs</a>.</p>
<p>Example:</p>
<pre><code class=3D"hljs css">&gt;&gt;&gt; <span class=3D"hljs-selector-tag=
">pyboy</span><span class=3D"hljs-selector-class">.tilemap_window</span><sp=
an class=3D"hljs-selector-attr">[8,8]</span>
1
&gt;&gt;&gt; <span class=3D"hljs-selector-tag">pyboy</span><span class=3D"h=
ljs-selector-class">.tilemap_window</span><span class=3D"hljs-selector-attr=
">[7:12,8]</span>
<span class=3D"hljs-selector-attr">[0, 1, 0, 1, 0]</span>
&gt;&gt;&gt; <span class=3D"hljs-selector-tag">pyboy</span><span class=3D"h=
ljs-selector-class">.tilemap_window</span><span class=3D"hljs-selector-attr=
">[7:12,8:11]</span>
<span class=3D"hljs-selector-attr">[[0, 1, 0, 1, 0]</span>, <span class=3D"=
hljs-selector-attr">[0, 2, 3, 4, 5]</span>, <span class=3D"hljs-selector-at=
tr">[0, 0, 6, 0, 0]</span>]

</code></pre>
<h2 id=3D"returns">Returns</h2>
<p><code><a title=3D"pyboy.api.tilemap.TileMap" href=3D"https://docs.pyboy.=
dk/api/tilemap.html#pyboy.api.tilemap.TileMap">TileMap</a></code>:
A TileMap object for the tile map.</p></section>
</dd>
<dt id=3D"pyboy.PyBoy.cartridge_title"><code class=3D"name">var <span class=
=3D"ident">cartridge_title</span></code></dt>
<dd>
<section class=3D"desc"><p>The title stored on the currently loaded cartrid=
ge ROM. The title is all upper-case ASCII and may
have been truncated to 11 characters.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.cartridge_title <span class=3D"hljs-comment"># Title of =
PyBoy's default ROM</span>
<span class=3D"hljs-string">'DEFAULT-ROM'</span>

</code></pre>
<h2 id=3D"returns">Returns</h2>
<dl>
<dt><code>str :</code></dt>
<dd>Game title</dd>
</dl></section>
</dd>
<dt id=3D"pyboy.PyBoy.game_wrapper"><code class=3D"name">var <span class=3D=
"ident">game_wrapper</span></code></dt>
<dd>
<section class=3D"desc"><p>Provides an instance of a game-specific or gener=
ic wrapper. The game is detected by the cartridge's hard-coded
game title (see <code><a title=3D"pyboy.PyBoy.cartridge_title" href=3D"http=
s://docs.pyboy.dk/index.html#pyboy.PyBoy.cartridge_title">PyBoy.cartridge_t=
itle</a></code>).</p>
<p>If a game-specific wrapper is not found, a generic wrapper will be retur=
ned.</p>
<p>To get more information, find the wrapper for your game in <code><a titl=
e=3D"pyboy.plugins" href=3D"https://docs.pyboy.dk/plugins/index.html">pyboy=
.plugins</a></code>.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.game_wrapper.start_game()
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.game_wrapper.reset_game=
()

</code></pre>
<h2 id=3D"returns">Returns</h2>
<p><code><a title=3D"pyboy.plugins.base_plugin.PyBoyGameWrapper" href=3D"ht=
tps://docs.pyboy.dk/plugins/base_plugin.html#pyboy.plugins.base_plugin.PyBo=
yGameWrapper">PyBoyGameWrapper</a></code>:
A game-specific wrapper object.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id=3D"pyboy.PyBoy.tick"><code class=3D"name flex">
<span>def <span class=3D"ident">tick</span></span>(<span>self, count=3D1, r=
ender=3DTrue)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Progresses the emulator ahead by <code>count</co=
de> frame(s).</p>
<p>To run the emulator in real-time, it will need to process 60 frames a se=
cond (for example in a while-loop).
This function will block for roughly 16,67ms per frame, to not run faster t=
han real-time, unless you specify
otherwise with the <code><a title=3D"pyboy.PyBoy.set_emulation_speed" href=
=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoy.set_emulation_speed">PyBoy=
.set_emulation_speed()</a></code> method.</p>
<p>If you need finer control than 1 frame, have a look at <code><a title=3D=
"pyboy.PyBoy.hook_register" href=3D"https://docs.pyboy.dk/index.html#pyboy.=
PyBoy.hook_register">PyBoy.hook_register()</a></code> to inject code at a s=
pecific point
in the game.</p>
<p>Setting <code>render</code> to <code>True</code> will make PyBoy render =
the screen for <em>the last frame</em> of this tick. This can be seen
as a type of "frameskipping" optimization.</p>
<p>For AI training, it's adviced to use as high a count as practical, as it=
 will otherwise reduce performance
substantially. While setting <code>render</code> to <code>False</code>, you=
 can still access the <code><a title=3D"pyboy.PyBoy.game_area" href=3D"http=
s://docs.pyboy.dk/index.html#pyboy.PyBoy.game_area">PyBoy.game_area()</a></=
code> to get a simpler
representation of the game.</p>
<p>If <code>render</code> was enabled, use <code><a title=3D"pyboy.api.scre=
en.Screen" href=3D"https://docs.pyboy.dk/api/screen.html#pyboy.api.screen.S=
creen">Screen</a></code> to get a NumPy buffer or raw memory buffer.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.tick() <span class=3D"hljs-comment"># Progress 1 frame w=
ith rendering</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">1</span>) <span class=3D"hljs-comment"># Progress 1 frame with re=
ndering</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">60</span>, <span class=3D"hljs-keyword">False</span>) <span class=
=3D"hljs-comment"># Progress 60 frames *without* rendering</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">60</span>, <span class=3D"hljs-keyword">True</span>) <span class=
=3D"hljs-comment"># Progress 60 frames and render *only the last frame*</sp=
an>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
for</span> _ <span class=3D"hljs-keyword">in</span> range(<span class=3D"hl=
js-number">60</span>): <span class=3D"hljs-comment"># Progress 60 frames an=
d render every frame</span>
<span class=3D"hljs-meta">... </span>    <span class=3D"hljs-keyword">if</s=
pan> <span class=3D"hljs-keyword">not</span> pyboy.tick(<span class=3D"hljs=
-number">1</span>, <span class=3D"hljs-keyword">True</span>):
<span class=3D"hljs-meta">... </span>        <span class=3D"hljs-keyword">b=
reak</span>
&gt;&gt;&gt;
</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>count</code></strong> :=E2=80=82<code>int</code></dt>
<dd>Number of ticks to process</dd>
<dt><strong><code>render</code></strong> :=E2=80=82<code>bool</code></dt>
<dd>Whether to render an image for this tick</dd>
</dl>
<h2 id=3D"returns">Returns</h2>
<p>(True or False):
False if emulation has ended otherwise True</p></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">tick</span><span cl=
ass=3D"hljs-params">(self, count=3D<span class=3D"hljs-number">1</span>, re=
nder=3DTrue)</span>:</span>
    <span class=3D"hljs-string">"""
    Progresses the emulator ahead by `count` frame(s).

    To run the emulator in real-time, it will need to process 60 frames a s=
econd (for example in a while-loop).
    This function will block for roughly 16,67ms per frame, to not run fast=
er than real-time, unless you specify
    otherwise with the `PyBoy.set_emulation_speed` method.

    If you need finer control than 1 frame, have a look at `PyBoy.hook_regi=
ster` to inject code at a specific point
    in the game.

    Setting `render` to `True` will make PyBoy render the screen for *the l=
ast frame* of this tick. This can be seen
    as a type of "frameskipping" optimization.

    For AI training, it's adviced to use as high a count as practical, as i=
t will otherwise reduce performance
    substantially. While setting `render` to `False`, you can still access =
the `PyBoy.game_area` to get a simpler
    representation of the game.

    If `render` was enabled, use `pyboy.api.screen.Screen` to get a NumPy b=
uffer or raw memory buffer.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.tick() # Progress 1 frame with rendering
    True
    &gt;&gt;&gt; pyboy.tick(1) # Progress 1 frame with rendering
    True
    &gt;&gt;&gt; pyboy.tick(60, False) # Progress 60 frames *without* rende=
ring
    True
    &gt;&gt;&gt; pyboy.tick(60, True) # Progress 60 frames and render *only=
 the last frame*
    True
    &gt;&gt;&gt; for _ in range(60): # Progress 60 frames and render every =
frame
    ...     if not pyboy.tick(1, True):
    ...         break
    &gt;&gt;&gt;
    ```

    Args:
        count (int): Number of ticks to process
        render (bool): Whether to render an image for this tick
    Returns
    -------
    (True or False):
        False if emulation has ended otherwise True
    """</span>

    running =3D <span class=3D"hljs-keyword">False</span>
    <span class=3D"hljs-keyword">while</span> count !=3D <span class=3D"hlj=
s-number">0</span>:
        _render =3D render <span class=3D"hljs-keyword">and</span> count =
=3D=3D <span class=3D"hljs-number">1</span> <span class=3D"hljs-comment"># =
Only render on last tick to improve performance</span>
        running =3D self._tick(_render)
        count -=3D <span class=3D"hljs-number">1</span>
    <span class=3D"hljs-keyword">return</span> running</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.stop"><code class=3D"name flex">
<span>def <span class=3D"ident">stop</span></span>(<span>self, save=3DTrue)=
</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Gently stops the emulator and all sub-modules.</=
p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.stop() <span class=3D"hljs-comment"># Stop emulator and =
save game progress (cartridge RAM)</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.stop(<span class=3D"hlj=
s-keyword">False</span>) <span class=3D"hljs-comment"># Stop emulator and d=
iscard game progress (cartridge RAM)</span>

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>save</code></strong> :=E2=80=82<code>bool</code></dt>
<dd>Specify whether to save the game upon stopping. It will always be saved=
 in a file next to the
provided game-ROM.</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">stop</span><span cl=
ass=3D"hljs-params">(self, save=3DTrue)</span>:</span>
    <span class=3D"hljs-string">"""
    Gently stops the emulator and all sub-modules.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.stop() # Stop emulator and save game progress (cartr=
idge RAM)
    &gt;&gt;&gt; pyboy.stop(False) # Stop emulator and discard game progres=
s (cartridge RAM)

    ```

    Args:
        save (bool): Specify whether to save the game upon stopping. It wil=
l always be saved in a file next to the
            provided game-ROM.
    """</span>
    <span class=3D"hljs-keyword">if</span> self.initialized <span class=3D"=
hljs-keyword">and</span> <span class=3D"hljs-keyword">not</span> self.stopp=
ed:
        logger.info(<span class=3D"hljs-string">"##########################=
#"</span>)
        logger.info(<span class=3D"hljs-string">"# Emulator is turning off =
#"</span>)
        logger.info(<span class=3D"hljs-string">"##########################=
#"</span>)
        self._plugin_manager.stop()
        self.mb.stop(save)
        self.stopped =3D <span class=3D"hljs-keyword">True</span></code></p=
re>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.button"><code class=3D"name flex">
<span>def <span class=3D"ident">button</span></span>(<span>self, input, del=
ay=3D1)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Send input to PyBoy in the form of "a", "b", "st=
art", "select", "left", "right", "up" and "down".</p>
<p>The button will automatically be released at the following call to <code=
><a title=3D"pyboy.PyBoy.tick" href=3D"https://docs.pyboy.dk/index.html#pyb=
oy.PyBoy.tick">PyBoy.tick()</a></code>.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.button(<span class=3D"hljs-string">'a'</span>) <span cla=
ss=3D"hljs-comment"># Press button 'a' and release after `pyboy.tick()`</sp=
an>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' released</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.button(<span class=3D"h=
ljs-string">'a'</span>, <span class=3D"hljs-number">3</span>) <span class=
=3D"hljs-comment"># Press button 'a' and release after 3 `pyboy.tick()`</sp=
an>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' still pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' still pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' released</span>
<span class=3D"hljs-keyword">True</span>
</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :=E2=80=82<code>str</code></dt>
<dd>button to press</dd>
<dt><strong><code>delay</code></strong> :=E2=80=82<code>int</code>, optiona=
l</dt>
<dd>Number of frames to delay the release. Defaults to 1</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">button</span><span =
class=3D"hljs-params">(self, input, delay=3D<span class=3D"hljs-number">1</=
span>)</span>:</span>
    <span class=3D"hljs-string">"""
    Send input to PyBoy in the form of "a", "b", "start", "select", "left",=
 "right", "up" and "down".

    The button will automatically be released at the following call to `PyB=
oy.tick`.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.button('a') # Press button 'a' and release after `py=
boy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' released
    True
    &gt;&gt;&gt; pyboy.button('a', 3) # Press button 'a' and release after =
3 `pyboy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' released
    True
    ```

    Args:
        input (str): button to press
        delay (int, optional): Number of frames to delay the release. Defau=
lts to 1
    """</span>
    input =3D input.lower()
    <span class=3D"hljs-keyword">if</span> input =3D=3D <span class=3D"hljs=
-string">"left"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_LEFT)
        self.send_input(WindowEvent.RELEASE_ARROW_LEFT, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"right"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
        self.send_input(WindowEvent.RELEASE_ARROW_RIGHT, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"up"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_UP)
        self.send_input(WindowEvent.RELEASE_ARROW_UP, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"down"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_DOWN)
        self.send_input(WindowEvent.RELEASE_ARROW_DOWN, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"a"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_A)
        self.send_input(WindowEvent.RELEASE_BUTTON_A, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"b"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_B)
        self.send_input(WindowEvent.RELEASE_BUTTON_B, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"start"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_START)
        self.send_input(WindowEvent.RELEASE_BUTTON_START, delay)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"select"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
        self.send_input(WindowEvent.RELEASE_BUTTON_SELECT, delay)
    <span class=3D"hljs-keyword">else</span>:
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"Unrecognized input:"</span>, input)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.button_press"><code class=3D"name flex">
<span>def <span class=3D"ident">button_press</span></span>(<span>self, inpu=
t)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Send input to PyBoy in the form of "a", "b", "st=
art", "select", "left", "right", "up" and "down".</p>
<p>The button will remain press until explicitly released with <code><a tit=
le=3D"pyboy.PyBoy.button_release" href=3D"https://docs.pyboy.dk/index.html#=
pyboy.PyBoy.button_release">PyBoy.button_release()</a></code> or <code><a t=
itle=3D"pyboy.PyBoy.send_input" href=3D"https://docs.pyboy.dk/index.html#py=
boy.PyBoy.send_input">PyBoy.send_input()</a></code>.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.button_press(<span class=3D"hljs-string">'a'</span>) <sp=
an class=3D"hljs-comment"># Press button 'a' and keep pressed after `PyBoy.=
tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' still pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.button_release(<span cl=
ass=3D"hljs-string">'a'</span>) <span class=3D"hljs-comment"># Release butt=
on 'a' on next call to `PyBoy.tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' released</span>
<span class=3D"hljs-keyword">True</span>

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :=E2=80=82<code>str</code></dt>
<dd>button to press</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">button_press</span>=
<span class=3D"hljs-params">(self, input)</span>:</span>
    <span class=3D"hljs-string">"""
    Send input to PyBoy in the form of "a", "b", "start", "select", "left",=
 "right", "up" and "down".

    The button will remain press until explicitly released with `PyBoy.butt=
on_release` or `PyBoy.send_input`.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.button_press('a') # Press button 'a' and keep presse=
d after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
    True
    &gt;&gt;&gt; pyboy.button_release('a') # Release button 'a' on next cal=
l to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' released
    True

    ```

    Args:
        input (str): button to press
    """</span>
    input =3D input.lower()

    <span class=3D"hljs-keyword">if</span> input =3D=3D <span class=3D"hljs=
-string">"left"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_LEFT)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"right"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_RIGHT)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"up"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_UP)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"down"</span>:
        self.send_input(WindowEvent.PRESS_ARROW_DOWN)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"a"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_A)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"b"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_B)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"start"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_START)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"select"</span>:
        self.send_input(WindowEvent.PRESS_BUTTON_SELECT)
    <span class=3D"hljs-keyword">else</span>:
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"Unrecognized input"</span>)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.button_release"><code class=3D"name flex">
<span>def <span class=3D"ident">button_release</span></span>(<span>self, in=
put)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Send input to PyBoy in the form of "a", "b", "st=
art", "select", "left", "right", "up" and "down".</p>
<p>This will release a button after a call to <code><a title=3D"pyboy.PyBoy=
.button_press" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoy.button_=
press">PyBoy.button_press()</a></code> or <code><a title=3D"pyboy.PyBoy.sen=
d_input" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoy.send_input">P=
yBoy.send_input()</a></code>.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.button_press(<span class=3D"hljs-string">'a'</span>) <sp=
an class=3D"hljs-comment"># Press button 'a' and keep pressed after `PyBoy.=
tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' still pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.button_release(<span cl=
ass=3D"hljs-string">'a'</span>) <span class=3D"hljs-comment"># Release butt=
on 'a' on next call to `PyBoy.tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' released</span>
<span class=3D"hljs-keyword">True</span>

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>input</code></strong> :=E2=80=82<code>str</code></dt>
<dd>button to release</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">button_release</spa=
n><span class=3D"hljs-params">(self, input)</span>:</span>
    <span class=3D"hljs-string">"""
    Send input to PyBoy in the form of "a", "b", "start", "select", "left",=
 "right", "up" and "down".

    This will release a button after a call to `PyBoy.button_press` or `PyB=
oy.send_input`.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.button_press('a') # Press button 'a' and keep presse=
d after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
    True
    &gt;&gt;&gt; pyboy.button_release('a') # Release button 'a' on next cal=
l to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' released
    True

    ```

    Args:
        input (str): button to release
    """</span>
    input =3D input.lower()
    <span class=3D"hljs-keyword">if</span> input =3D=3D <span class=3D"hljs=
-string">"left"</span>:
        self.send_input(WindowEvent.RELEASE_ARROW_LEFT)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"right"</span>:
        self.send_input(WindowEvent.RELEASE_ARROW_RIGHT)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"up"</span>:
        self.send_input(WindowEvent.RELEASE_ARROW_UP)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"down"</span>:
        self.send_input(WindowEvent.RELEASE_ARROW_DOWN)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"a"</span>:
        self.send_input(WindowEvent.RELEASE_BUTTON_A)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"b"</span>:
        self.send_input(WindowEvent.RELEASE_BUTTON_B)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"start"</span>:
        self.send_input(WindowEvent.RELEASE_BUTTON_START)
    <span class=3D"hljs-keyword">elif</span> input =3D=3D <span class=3D"hl=
js-string">"select"</span>:
        self.send_input(WindowEvent.RELEASE_BUTTON_SELECT)
    <span class=3D"hljs-keyword">else</span>:
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"Unrecognized input"</span>)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.send_input"><code class=3D"name flex">
<span>def <span class=3D"ident">send_input</span></span>(<span>self, event,=
 delay=3D0)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Send a single input to control the emulator. Thi=
s is both Game Boy buttons and emulator controls. See
<code><a title=3D"pyboy.utils.WindowEvent" href=3D"https://docs.pyboy.dk/ut=
ils.html#pyboy.utils.WindowEvent">WindowEvent</a></code> for which events t=
o send.</p>
<p>Consider using <code><a title=3D"pyboy.PyBoy.button" href=3D"https://doc=
s.pyboy.dk/index.html#pyboy.PyBoy.button">PyBoy.button()</a></code> instead=
 for easier access.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-keyword">from</span> pyboy.utils <span cla=
ss=3D"hljs-keyword">import</span> WindowEvent
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.send_input(WindowEvent.=
PRESS_BUTTON_A) <span class=3D"hljs-comment"># Press button 'a' and keep pr=
essed after `PyBoy.tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' still pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.send_input(WindowEvent.=
RELEASE_BUTTON_A) <span class=3D"hljs-comment"># Release button 'a' on next=
 call to `PyBoy.tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' released</span>
<span class=3D"hljs-keyword">True</span>
</code></pre>
<p>And even simpler with delay:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-keyword">from</span> pyboy.utils <span cla=
ss=3D"hljs-keyword">import</span> WindowEvent
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.send_input(WindowEvent.=
PRESS_BUTTON_A) <span class=3D"hljs-comment"># Press button 'a' and keep pr=
essed after `PyBoy.tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.send_input(WindowEvent.=
RELEASE_BUTTON_A, <span class=3D"hljs-number">2</span>) <span class=3D"hljs=
-comment"># Release button 'a' on third call to `PyBoy.tick()`</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' still pressed</span>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># Button 'a' released</span>
<span class=3D"hljs-keyword">True</span>
</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :=E2=80=82<code>pyboy.WindowEvent</=
code></dt>
<dd>The event to send</dd>
<dt><strong><code>delay</code></strong> :=E2=80=82<code>int</code></dt>
<dd>0 for immediately, number of frames to delay the input</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">send_input</span><s=
pan class=3D"hljs-params">(self, event, delay=3D<span class=3D"hljs-number"=
>0</span>)</span>:</span>
    <span class=3D"hljs-string">"""
    Send a single input to control the emulator. This is both Game Boy butt=
ons and emulator controls. See
    `pyboy.utils.WindowEvent` for which events to send.

    Consider using `PyBoy.button` instead for easier access.

    Example:
    ```python
    &gt;&gt;&gt; from pyboy.utils import WindowEvent
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press butto=
n 'a' and keep pressed after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
    True
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A) # Release b=
utton 'a' on next call to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' released
    True
    ```

    And even simpler with delay:
    ```python
    &gt;&gt;&gt; from pyboy.utils import WindowEvent
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.PRESS_BUTTON_A) # Press butto=
n 'a' and keep pressed after `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.send_input(WindowEvent.RELEASE_BUTTON_A, 2) # Releas=
e button 'a' on third call to `PyBoy.tick()`
    &gt;&gt;&gt; pyboy.tick() # Button 'a' pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' still pressed
    True
    &gt;&gt;&gt; pyboy.tick() # Button 'a' released
    True
    ```

    Args:
        event (pyboy.WindowEvent): The event to send
        delay (int): 0 for immediately, number of frames to delay the input
    """</span>

    <span class=3D"hljs-keyword">if</span> delay:
        <span class=3D"hljs-keyword">assert</span> delay &gt; <span class=
=3D"hljs-number">0</span>, <span class=3D"hljs-string">"Only positive integ=
ers allowed"</span>
        heapq.heappush(self.queued_input, (self.frame_count + delay, event)=
)
    <span class=3D"hljs-keyword">else</span>:
        self.events.append(WindowEvent(event))</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.save_state"><code class=3D"name flex">
<span>def <span class=3D"ident">save_state</span></span>(<span>self, file_l=
ike_object)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Saves the complete state of the emulator. It can=
 be called at any time, and enable you to revert any progress in
a game.</p>
<p>You can either save it to a file, or in-memory. The following two exampl=
es will provide the file handle in each
case. Remember to <code>seek</code> the in-memory buffer to the beginning b=
efore calling <code><a title=3D"pyboy.PyBoy.load_state" href=3D"https://doc=
s.pyboy.dk/index.html#pyboy.PyBoy.load_state">PyBoy.load_state()</a></code>=
:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-comment"># Save to file</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
with</span> open(<span class=3D"hljs-string">"state_file.state"</span>, <sp=
an class=3D"hljs-string">"wb"</span>) <span class=3D"hljs-keyword">as</span=
> f:
<span class=3D"hljs-meta">... </span>    pyboy.save_state(f)
&gt;&gt;&gt;
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-comment">=
# Save to memory</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
import</span> io
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
with</span> io.BytesIO() <span class=3D"hljs-keyword">as</span> f:
<span class=3D"hljs-meta">... </span>    f.seek(<span class=3D"hljs-number"=
>0</span>)
<span class=3D"hljs-meta">... </span>    pyboy.save_state(f)
<span class=3D"hljs-number">0</span>

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :=E2=80=82<code>io.Buffe=
redIOBase</code></dt>
<dd>A file-like object for which to write the emulator state.</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">save_state</span><s=
pan class=3D"hljs-params">(self, file_like_object)</span>:</span>
    <span class=3D"hljs-string">"""
    Saves the complete state of the emulator. It can be called at any time,=
 and enable you to revert any progress in
    a game.

    You can either save it to a file, or in-memory. The following two examp=
les will provide the file handle in each
    case. Remember to `seek` the in-memory buffer to the beginning before c=
alling `PyBoy.load_state`:

    ```python
    &gt;&gt;&gt; # Save to file
    &gt;&gt;&gt; with open("state_file.state", "wb") as f:
    ...     pyboy.save_state(f)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Save to memory
    &gt;&gt;&gt; import io
    &gt;&gt;&gt; with io.BytesIO() as f:
    ...     f.seek(0)
    ...     pyboy.save_state(f)
    0

    ```

    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which =
to write the emulator state.
    """</span>

    <span class=3D"hljs-keyword">if</span> isinstance(file_like_object, str=
):
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"String not allowed. Did you specify a filepath instead of a f=
ile-like object?"</span>)

    <span class=3D"hljs-keyword">if</span> file_like_object.__class__.__nam=
e__ =3D=3D <span class=3D"hljs-string">"TextIOWrapper"</span>:
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"Text file not allowed. Did you specify open(..., 'wb')?"</spa=
n>)

    self.mb.save_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.load_state"><code class=3D"name flex">
<span>def <span class=3D"ident">load_state</span></span>(<span>self, file_l=
ike_object)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Restores the complete state of the emulator. It =
can be called at any time, and enable you to revert any progress
in a game.</p>
<p>You can either load it from a file, or from memory. See <code><a title=
=3D"pyboy.PyBoy.save_state" href=3D"https://docs.pyboy.dk/index.html#pyboy.=
PyBoy.save_state">PyBoy.save_state()</a></code> for how to save the state, =
before you
can load it here.</p>
<p>To load a file, remember to load it as bytes:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-comment"># Load file</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-keyword">=
with</span> open(<span class=3D"hljs-string">"state_file.state"</span>, <sp=
an class=3D"hljs-string">"rb"</span>) <span class=3D"hljs-keyword">as</span=
> f:
<span class=3D"hljs-meta">... </span>    pyboy.load_state(f)
&gt;&gt;&gt;
</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :=E2=80=82<code>io.Buffe=
redIOBase</code></dt>
<dd>A file-like object for which to read the emulator state.</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">load_state</span><s=
pan class=3D"hljs-params">(self, file_like_object)</span>:</span>
    <span class=3D"hljs-string">"""
    Restores the complete state of the emulator. It can be called at any ti=
me, and enable you to revert any progress
    in a game.

    You can either load it from a file, or from memory. See `PyBoy.save_sta=
te` for how to save the state, before you
    can load it here.

    To load a file, remember to load it as bytes:
    ```python
    &gt;&gt;&gt; # Load file
    &gt;&gt;&gt; with open("state_file.state", "rb") as f:
    ...     pyboy.load_state(f)
    &gt;&gt;&gt;
    ```

    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which =
to read the emulator state.
    """</span>

    <span class=3D"hljs-keyword">if</span> isinstance(file_like_object, str=
):
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"String not allowed. Did you specify a filepath instead of a f=
ile-like object?"</span>)

    <span class=3D"hljs-keyword">if</span> file_like_object.__class__.__nam=
e__ =3D=3D <span class=3D"hljs-string">"TextIOWrapper"</span>:
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"Text file not allowed. Did you specify open(..., 'rb')?"</spa=
n>)

    self.mb.load_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.game_area_dimensions"><code class=3D"name flex">
<span>def <span class=3D"ident">game_area_dimensions</span></span>(<span>se=
lf, x, y, width, height, follow_scrolling=3DTrue)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>If using the generic game wrapper (see <code><a =
title=3D"pyboy.PyBoy.game_wrapper" href=3D"https://docs.pyboy.dk/index.html=
#pyboy.PyBoy.game_wrapper">PyBoy.game_wrapper</a></code>), you can use this=
 to set the section of the
tilemaps to extract. This will default to the entire tilemap.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.game_wrapper.shape
(<span class=3D"hljs-number">32</span>, <span class=3D"hljs-number">32</spa=
n>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.game_area_dimensions(<s=
pan class=3D"hljs-number">2</span>, <span class=3D"hljs-number">2</span>, <=
span class=3D"hljs-number">10</span>, <span class=3D"hljs-number">18</span>=
, <span class=3D"hljs-keyword">False</span>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.game_wrapper.shape
(<span class=3D"hljs-number">10</span>, <span class=3D"hljs-number">18</spa=
n>)
</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :=E2=80=82<code>int</code></dt>
<dd>Offset from top-left corner of the screen</dd>
<dt><strong><code>y</code></strong> :=E2=80=82<code>int</code></dt>
<dd>Offset from top-left corner of the screen</dd>
<dt><strong><code>width</code></strong> :=E2=80=82<code>int</code></dt>
<dd>Width of game area</dd>
<dt><strong><code>height</code></strong> :=E2=80=82<code>int</code></dt>
<dd>Height of game area</dd>
<dt><strong><code>follow_scrolling</code></strong> :=E2=80=82<code>bool</co=
de></dt>
<dd>Whether to follow the scrolling of <a href=3D"https://gbdev.io/pandocs/=
Scrolling.html">SCX and SCY</a></dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">game_area_dimension=
s</span><span class=3D"hljs-params">(self, x, y, width, height, follow_scro=
lling=3DTrue)</span>:</span>
    <span class=3D"hljs-string">"""
    If using the generic game wrapper (see `pyboy.PyBoy.game_wrapper`), you=
 can use this to set the section of the
    tilemaps to extract. This will default to the entire tilemap.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.game_wrapper.shape
    (32, 32)
    &gt;&gt;&gt; pyboy.game_area_dimensions(2, 2, 10, 18, False)
    &gt;&gt;&gt; pyboy.game_wrapper.shape
    (10, 18)
    ```

    Args:
        x (int): Offset from top-left corner of the screen
        y (int): Offset from top-left corner of the screen
        width (int): Width of game area
        height (int): Height of game area
        follow_scrolling (bool): Whether to follow the scrolling of [SCX an=
d SCY](https://gbdev.io/pandocs/Scrolling.html)
    """</span>
    self.game_wrapper._set_dimensions(x, y, width, height, follow_scrolling=
=3D<span class=3D"hljs-keyword">True</span>)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.game_area_collision"><code class=3D"name flex">
<span>def <span class=3D"ident">game_area_collision</span></span>(<span>sel=
f)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Some game wrappers define a collision map. Check=
 if your game wrapper has this feature implemented: <code><a title=3D"pyboy=
.plugins" href=3D"https://docs.pyboy.dk/plugins/index.html">pyboy.plugins</=
a></code>.</p>
<p>The output will be unique for each game wrapper.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-comment"># This example show nothing, but =
a supported game will</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.game_area_collision()
array([[<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>],
       [<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number"=
>0</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number=
">0</span>, <span class=3D"hljs-number">0</span>]], dtype=3Duint32)

</code></pre>
<h2 id=3D"returns">Returns</h2>
<dl>
<dt><code>memoryview:</code></dt>
<dd>Simplified 2-dimensional memoryview of the collision map</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">game_area_collision=
</span><span class=3D"hljs-params">(self)</span>:</span>
    <span class=3D"hljs-string">"""
    Some game wrappers define a collision map. Check if your game wrapper h=
as this feature implemented: `pyboy.plugins`.

    The output will be unique for each game wrapper.

    Example:
    ```python
    &gt;&gt;&gt; # This example show nothing, but a supported game will
    &gt;&gt;&gt; pyboy.game_area_collision()
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=3Duint32)

    ```

    Returns
    -------
    memoryview:
        Simplified 2-dimensional memoryview of the collision map
    """</span>
    <span class=3D"hljs-keyword">return</span> self.game_wrapper.game_area_=
collision()</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.game_area_mapping"><code class=3D"name flex">
<span>def <span class=3D"ident">game_area_mapping</span></span>(<span>self,=
 mapping, sprite_offset=3D0)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Define custom mappings for tile identifiers in t=
he game area.</p>
<p>Example of custom mapping:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>mapping =3D [x <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(<span class=3D"hljs-number">384</sp=
an>)] <span class=3D"hljs-comment"># 1:1 mapping</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>mapping[<span class=3D"hljs-n=
umber">0</span>] =3D <span class=3D"hljs-number">0</span> <span class=3D"hl=
js-comment"># Map tile identifier 0 -&gt; 0</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>mapping[<span class=3D"hljs-n=
umber">1</span>] =3D <span class=3D"hljs-number">0</span> <span class=3D"hl=
js-comment"># Map tile identifier 1 -&gt; 0</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>mapping[<span class=3D"hljs-n=
umber">2</span>] =3D <span class=3D"hljs-number">0</span> <span class=3D"hl=
js-comment"># Map tile identifier 2 -&gt; 0</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>mapping[<span class=3D"hljs-n=
umber">3</span>] =3D <span class=3D"hljs-number">0</span> <span class=3D"hl=
js-comment"># Map tile identifier 3 -&gt; 0</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.game_area_mapping(mappi=
ng, <span class=3D"hljs-number">1000</span>)

</code></pre>
<p>Some game wrappers will supply mappings as well. See the specific docume=
ntation for your game wrapper:
<code><a title=3D"pyboy.plugins" href=3D"https://docs.pyboy.dk/plugins/inde=
x.html">pyboy.plugins</a></code>.</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.game_area_mapping(pyboy.game_wrapper.mapping_one_to_one,=
 <span class=3D"hljs-number">0</span>)

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong> :=E2=80=82<code>list</code> or <c=
ode>ndarray</code></dt>
<dd>list of 384 (DMG) or 768 (CGB) tile mappings. Use <code>None</code> to =
reset to a 1:1 mapping.</dd>
<dt><strong><code>sprite_offest</code></strong> :=E2=80=82<code>int</code><=
/dt>
<dd>Optional offset add to tile id for sprites</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">game_area_mapping</=
span><span class=3D"hljs-params">(self, mapping, sprite_offset=3D<span clas=
s=3D"hljs-number">0</span>)</span>:</span>
    <span class=3D"hljs-string">"""
    Define custom mappings for tile identifiers in the game area.

    Example of custom mapping:
    ```python
    &gt;&gt;&gt; mapping =3D [x for x in range(384)] # 1:1 mapping
    &gt;&gt;&gt; mapping[0] =3D 0 # Map tile identifier 0 -&gt; 0
    &gt;&gt;&gt; mapping[1] =3D 0 # Map tile identifier 1 -&gt; 0
    &gt;&gt;&gt; mapping[2] =3D 0 # Map tile identifier 2 -&gt; 0
    &gt;&gt;&gt; mapping[3] =3D 0 # Map tile identifier 3 -&gt; 0
    &gt;&gt;&gt; pyboy.game_area_mapping(mapping, 1000)

    ```

    Some game wrappers will supply mappings as well. See the specific docum=
entation for your game wrapper:
    `pyboy.plugins`.
    ```python
    &gt;&gt;&gt; pyboy.game_area_mapping(pyboy.game_wrapper.mapping_one_to_=
one, 0)

    ```

    Args:
        mapping (list or ndarray): list of 384 (DMG) or 768 (CGB) tile mapp=
ings. Use `None` to reset to a 1:1 mapping.
        sprite_offest (int): Optional offset add to tile id for sprites
    """</span>

    <span class=3D"hljs-keyword">if</span> mapping <span class=3D"hljs-keyw=
ord">is</span> <span class=3D"hljs-keyword">None</span>:
        mapping =3D [x <span class=3D"hljs-keyword">for</span> x <span clas=
s=3D"hljs-keyword">in</span> range(<span class=3D"hljs-number">768</span>)]

    <span class=3D"hljs-keyword">assert</span> isinstance(sprite_offset, in=
t)
    <span class=3D"hljs-keyword">assert</span> isinstance(mapping, (np.ndar=
ray, list))
    <span class=3D"hljs-keyword">assert</span> len(mapping) =3D=3D <span cl=
ass=3D"hljs-number">384</span> <span class=3D"hljs-keyword">or</span> len(m=
apping) =3D=3D <span class=3D"hljs-number">768</span>

    self.game_wrapper.game_area_mapping(mapping, sprite_offset)</code></pre=
>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.game_area"><code class=3D"name flex">
<span>def <span class=3D"ident">game_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Use this method to get a matrix of the "game are=
a" of the screen. This view is simplified to be perfect for
machine learning applications.</p>
<p>The layout will vary from game to game. Below is an example from Tetris:=
</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.game_area()
array([[ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>, <span class=3D"hljs-nu=
mber">130</span>, <span class=3D"hljs-number">130</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>, <span class=3D"hljs-number">130</span>, <span class=3D"hl=
js-number">130</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>],
       [ <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-number=
">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"hljs-n=
umber">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=3D"h=
ljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span class=
=3D"hljs-number">47</span>,  <span class=3D"hljs-number">47</span>,  <span =
class=3D"hljs-number">47</span>]], dtype=3Duint32)

</code></pre>
<p>If you want a "compressed", "minimal" or raw mapping of tiles, you can c=
hange the mapping using
<code><a title=3D"pyboy.PyBoy.game_area_mapping" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoy.game_area_mapping">PyBoy.game_area_mapping()</a>=
</code>. Either you'll have to supply your own mapping, or you can find one
that is built-in with the game wrapper plugin for your game. See <code><a t=
itle=3D"pyboy.PyBoy.game_area_mapping" href=3D"https://docs.pyboy.dk/index.=
html#pyboy.PyBoy.game_area_mapping">PyBoy.game_area_mapping()</a></code>.</=
p>
<h2 id=3D"returns">Returns</h2>
<dl>
<dt><code>memoryview:</code></dt>
<dd>Simplified 2-dimensional memoryview of the screen</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">game_area</span><sp=
an class=3D"hljs-params">(self)</span>:</span>
    <span class=3D"hljs-string">"""
    Use this method to get a matrix of the "game area" of the screen. This =
view is simplified to be perfect for
    machine learning applications.

    The layout will vary from game to game. Below is an example from Tetris=
:

    Example:
    ```python
    &gt;&gt;&gt; pyboy.game_area()
    array([[ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47, 130, 130,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47, 130, 130,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47],
           [ 47,  47,  47,  47,  47,  47,  47,  47,  47,  47]], dtype=3Duin=
t32)

    ```

    If you want a "compressed", "minimal" or raw mapping of tiles, you can =
change the mapping using
    `pyboy.PyBoy.game_area_mapping`. Either you'll have to supply your own =
mapping, or you can find one
    that is built-in with the game wrapper plugin for your game. See `pyboy=
.PyBoy.game_area_mapping`.

    Returns
    -------
    memoryview:
        Simplified 2-dimensional memoryview of the screen
    """</span>

    <span class=3D"hljs-keyword">return</span> self.game_wrapper.game_area(=
)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.set_emulation_speed"><code class=3D"name flex">
<span>def <span class=3D"ident">set_emulation_speed</span></span>(<span>sel=
f, target_speed)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Set the target emulation speed. It might loose a=
ccuracy of keeping the exact speed, when using a high
<code>target_speed</code>.</p>
<p>The speed is defined as a multiple of real-time. I.e <code>target_speed=
=3D2</code> is double speed.</p>
<p>A <code>target_speed</code> of <code>0</code> means unlimited. I.e. fast=
est possible execution.</p>
<p>Some window types do not implement a frame-limiter, and will always run =
at full speed.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.tick() <span class=3D"hljs-comment"># Delays 16.67ms</sp=
an>
<span class=3D"hljs-keyword">True</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.set_emulation_speed(<sp=
an class=3D"hljs-number">0</span>) <span class=3D"hljs-comment"># Disable l=
imit</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick() <span class=3D"h=
ljs-comment"># As fast as possible</span>
<span class=3D"hljs-keyword">True</span>
</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>target_speed</code></strong> :=E2=80=82<code>int</code></=
dt>
<dd>Target emulation speed as multiplier of real-time.</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">set_emulation_speed=
</span><span class=3D"hljs-params">(self, target_speed)</span>:</span>
    <span class=3D"hljs-string">"""
    Set the target emulation speed. It might loose accuracy of keeping the =
exact speed, when using a high
    `target_speed`.

    The speed is defined as a multiple of real-time. I.e `target_speed=3D2`=
 is double speed.

    A `target_speed` of `0` means unlimited. I.e. fastest possible executio=
n.

    Some window types do not implement a frame-limiter, and will always run=
 at full speed.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.tick() # Delays 16.67ms
    True
    &gt;&gt;&gt; pyboy.set_emulation_speed(0) # Disable limit
    &gt;&gt;&gt; pyboy.tick() # As fast as possible
    True
    ```

    Args:
        target_speed (int): Target emulation speed as multiplier of real-ti=
me.
    """</span>
    <span class=3D"hljs-keyword">if</span> self.initialized <span class=3D"=
hljs-keyword">and</span> self._plugin_manager.window_null_enabled:
        logger.warning(
            <span class=3D"hljs-string">'This window type does not support =
frame-limiting. `pyboy.set_emulation_speed(...)` will have no effect, as it=
\'s always running at full speed.'</span>
        )

    <span class=3D"hljs-keyword">if</span> target_speed &gt; <span class=3D=
"hljs-number">5</span>:
        logger.warning(<span class=3D"hljs-string">"The emulation speed mig=
ht not be accurate when speed-target is higher than 5"</span>)
    self.target_emulationspeed =3D target_speed</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.symbol_lookup"><code class=3D"name flex">
<span>def <span class=3D"ident">symbol_lookup</span></span>(<span>self, sym=
bol)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Look up a specific symbol from provided symbols =
file.</p>
<p>This can be useful in combination with <code><a title=3D"pyboy.PyBoy.mem=
ory" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoy.memory">PyBoy.mem=
ory</a></code> or even <code><a title=3D"pyboy.PyBoy.hook_register" href=3D=
"https://docs.pyboy.dk/index.html#pyboy.PyBoy.hook_register">PyBoy.hook_reg=
ister()</a></code>.</p>
<p>See <code><a title=3D"pyboy.PyBoy.hook_register" href=3D"https://docs.py=
boy.dk/index.html#pyboy.PyBoy.hook_register">PyBoy.hook_register()</a></cod=
e> for how to load symbol into PyBoy.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-comment"># Directly</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[pyboy.symbol_loo=
kup(<span class=3D"hljs-string">"Tileset"</span>)]
<span class=3D"hljs-number">0</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-comment">=
# By bank and address</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>bank, addr =3D pyboy.symbol_l=
ookup(<span class=3D"hljs-string">"Tileset"</span>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[bank, addr]
<span class=3D"hljs-number">0</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[bank, addr:addr+=
<span class=3D"hljs-number">10</span>]
[<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0</span>=
, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0</span=
>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">0</spa=
n>, <span class=3D"hljs-number">102</span>, <span class=3D"hljs-number">102=
</span>, <span class=3D"hljs-number">102</span>, <span class=3D"hljs-number=
">102</span>]

</code></pre>
<h2 id=3D"returns">Returns</h2>
<p>(int, int):
ROM/RAM bank, address</p></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">symbol_lookup</span=
><span class=3D"hljs-params">(self, symbol)</span>:</span>
    <span class=3D"hljs-string">"""
    Look up a specific symbol from provided symbols file.

    This can be useful in combination with `PyBoy.memory` or even `PyBoy.ho=
ok_register`.

    See `PyBoy.hook_register` for how to load symbol into PyBoy.

    Example:
    ```python
    &gt;&gt;&gt; # Directly
    &gt;&gt;&gt; pyboy.memory[pyboy.symbol_lookup("Tileset")]
    0
    &gt;&gt;&gt; # By bank and address
    &gt;&gt;&gt; bank, addr =3D pyboy.symbol_lookup("Tileset")
    &gt;&gt;&gt; pyboy.memory[bank, addr]
    0
    &gt;&gt;&gt; pyboy.memory[bank, addr:addr+10]
    [0, 0, 0, 0, 0, 0, 102, 102, 102, 102]

    ```
    Returns
    -------
    (int, int):
        ROM/RAM bank, address
    """</span>
    <span class=3D"hljs-keyword">return</span> self._lookup_symbol(symbol)<=
/code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.hook_register"><code class=3D"name flex">
<span>def <span class=3D"ident">hook_register</span></span>(<span>self, ban=
k, addr, callback, context)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Adds a hook into a specific bank and memory addr=
ess.
When the Game Boy executes this address, the provided callback function wil=
l be called.</p>
<p>By providing an object as <code>context</code>, you can later get access=
 to information inside and outside of the callback.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>context =3D <span class=3D"hljs-string">"Hello from hook"</spa=
n>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-function"=
><span class=3D"hljs-keyword">def</span> <span class=3D"hljs-title">my_call=
back</span><span class=3D"hljs-params">(context)</span>:</span>
<span class=3D"hljs-meta">... </span>    print(context)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_register(<span cla=
ss=3D"hljs-number">0</span>, <span class=3D"hljs-number">0x100</span>, my_c=
allback, context)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">70</span>)
Hello <span class=3D"hljs-keyword">from</span> hook
<span class=3D"hljs-keyword">True</span>

</code></pre>
<p>If a symbol file is loaded, this function can also automatically resolve=
 a bank and address from a symbol. To
enable this, you'll need to place a <code>.sym</code> file next to your ROM=
, or provide it using:
<code>PyBoy(..., symbols=3D"game_rom.gb.sym")</code>.</p>
<p>Then provide <code>None</code> for <code>bank</code> and the symbol for =
<code>addr</code> to trigger the automatic lookup.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-comment"># Continued example above</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_register(<span cla=
ss=3D"hljs-keyword">None</span>, <span class=3D"hljs-string">"Main.move"</s=
pan>, <span class=3D"hljs-keyword">lambda</span> x: print(x), <span class=
=3D"hljs-string">"Hello from hook2"</span>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">80</span>)
Hello <span class=3D"hljs-keyword">from</span> hook2
<span class=3D"hljs-keyword">True</span>

</code></pre>
<p><strong>NOTE</strong>:</p>
<p>Don't register hooks to something that isn't executable (graphics data e=
tc.). This will cause your game to show
weird behavior or crash. Hooks are installed by replacing the instruction a=
t the bank and address with a special
opcode (<code>0xDB</code>). If the address is read by the game instead of e=
xecuted as code, this value will be read instead.</p>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>bank</code></strong> :=E2=80=82<code>int</code> or <code>=
None</code></dt>
<dd>ROM or RAM bank (None for symbol lookup)</dd>
<dt><strong><code>addr</code></strong> :=E2=80=82<code>int</code> or <code>=
str</code></dt>
<dd>Address in the Game Boy's address space (str for symbol lookup)</dd>
<dt><strong><code>callback</code></strong> :=E2=80=82<code>func</code></dt>
<dd>A function which takes <code>context</code> as argument</dd>
<dt><strong><code>context</code></strong> :=E2=80=82<code>object</code></dt=
>
<dd>Argument to pass to callback when hook is called</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">hook_register</span=
><span class=3D"hljs-params">(self, bank, addr, callback, context)</span>:<=
/span>
    <span class=3D"hljs-string">"""
    Adds a hook into a specific bank and memory address.
    When the Game Boy executes this address, the provided callback function=
 will be called.

    By providing an object as `context`, you can later get access to inform=
ation inside and outside of the callback.

    Example:
    ```python
    &gt;&gt;&gt; context =3D "Hello from hook"
    &gt;&gt;&gt; def my_callback(context):
    ...     print(context)
    &gt;&gt;&gt; pyboy.hook_register(0, 0x100, my_callback, context)
    &gt;&gt;&gt; pyboy.tick(70)
    Hello from hook
    True

    ```

    If a symbol file is loaded, this function can also automatically resolv=
e a bank and address from a symbol. To
    enable this, you'll need to place a `.sym` file next to your ROM, or pr=
ovide it using:
    `PyBoy(..., symbols=3D"game_rom.gb.sym")`.

    Then provide `None` for `bank` and the symbol for `addr` to trigger the=
 automatic lookup.

    Example:
    ```python
    &gt;&gt;&gt; # Continued example above
    &gt;&gt;&gt; pyboy.hook_register(None, "Main.move", lambda x: print(x),=
 "Hello from hook2")
    &gt;&gt;&gt; pyboy.tick(80)
    Hello from hook2
    True

    ```

    **NOTE**:

    Don't register hooks to something that isn't executable (graphics data =
etc.). This will cause your game to show
    weird behavior or crash. Hooks are installed by replacing the instructi=
on at the bank and address with a special
    opcode (`0xDB`). If the address is read by the game instead of executed=
 as code, this value will be read instead.

    Args:
        bank (int or None): ROM or RAM bank (None for symbol lookup)
        addr (int or str): Address in the Game Boy's address space (str for=
 symbol lookup)
        callback (func): A function which takes `context` as argument
        context (object): Argument to pass to callback when hook is called
    """</span>
    <span class=3D"hljs-keyword">if</span> bank <span class=3D"hljs-keyword=
">is</span> <span class=3D"hljs-keyword">None</span> <span class=3D"hljs-ke=
yword">and</span> isinstance(addr, str):
        bank, addr =3D self._lookup_symbol(addr)

    opcode =3D self.memory[bank, addr]
    <span class=3D"hljs-keyword">if</span> opcode =3D=3D <span class=3D"hlj=
s-number">0xDB</span>:
        <span class=3D"hljs-keyword">raise</span> ValueError(<span class=3D=
"hljs-string">"Hook already registered for this bank and address."</span>)
    self.mb.breakpoint_add(bank, addr)
    bank_addr_opcode =3D (bank &amp; <span class=3D"hljs-number">0xFF</span=
>) &lt;&lt; <span class=3D"hljs-number">24</span> | (addr &amp; <span class=
=3D"hljs-number">0xFFFF</span>) &lt;&lt; <span class=3D"hljs-number">8</spa=
n> | (opcode &amp; <span class=3D"hljs-number">0xFF</span>)
    logger.debug(<span class=3D"hljs-string">"Adding hook for opcode %08x"<=
/span>, bank_addr_opcode)
    self._hooks[bank_addr_opcode] =3D (callback, context)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.hook_deregister"><code class=3D"name flex">
<span>def <span class=3D"ident">hook_deregister</span></span>(<span>self, b=
ank, addr)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Remove a previously registered hook from a speci=
fic bank and memory address.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>context =3D <span class=3D"hljs-string">"Hello from hook"</spa=
n>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-function"=
><span class=3D"hljs-keyword">def</span> <span class=3D"hljs-title">my_call=
back</span><span class=3D"hljs-params">(context)</span>:</span>
<span class=3D"hljs-meta">... </span>    print(context)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_register(<span cla=
ss=3D"hljs-number">0</span>, <span class=3D"hljs-number">0x2000</span>, my_=
callback, context)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_deregister(<span c=
lass=3D"hljs-number">0</span>, <span class=3D"hljs-number">0x2000</span>)

</code></pre>
<p>This function can also deregister a hook based on a symbol. See <code><a=
 title=3D"pyboy.PyBoy.hook_register" href=3D"https://docs.pyboy.dk/index.ht=
ml#pyboy.PyBoy.hook_register">PyBoy.hook_register()</a></code> for details.=
</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.hook_register(<span class=3D"hljs-keyword">None</span>, =
<span class=3D"hljs-string">"Main"</span>, <span class=3D"hljs-keyword">lam=
bda</span> x: print(x), <span class=3D"hljs-string">"Hello from hook"</span=
>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_deregister(<span c=
lass=3D"hljs-keyword">None</span>, <span class=3D"hljs-string">"Main"</span=
>)

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>bank</code></strong> :=E2=80=82<code>int</code> or <code>=
None</code></dt>
<dd>ROM or RAM bank (None for symbol lookup)</dd>
<dt><strong><code>addr</code></strong> :=E2=80=82<code>int</code> or <code>=
str</code></dt>
<dd>Address in the Game Boy's address space (str for symbol lookup)</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">hook_deregister</sp=
an><span class=3D"hljs-params">(self, bank, addr)</span>:</span>
    <span class=3D"hljs-string">"""
    Remove a previously registered hook from a specific bank and memory add=
ress.

    Example:
    ```python
    &gt;&gt;&gt; context =3D "Hello from hook"
    &gt;&gt;&gt; def my_callback(context):
    ...     print(context)
    &gt;&gt;&gt; pyboy.hook_register(0, 0x2000, my_callback, context)
    &gt;&gt;&gt; pyboy.hook_deregister(0, 0x2000)

    ```

    This function can also deregister a hook based on a symbol. See `PyBoy.=
hook_register` for details.

    Example:
    ```python
    &gt;&gt;&gt; pyboy.hook_register(None, "Main", lambda x: print(x), "Hel=
lo from hook")
    &gt;&gt;&gt; pyboy.hook_deregister(None, "Main")

    ```

    Args:
        bank (int or None): ROM or RAM bank (None for symbol lookup)
        addr (int or str): Address in the Game Boy's address space (str for=
 symbol lookup)
    """</span>
    <span class=3D"hljs-keyword">if</span> bank <span class=3D"hljs-keyword=
">is</span> <span class=3D"hljs-keyword">None</span> <span class=3D"hljs-ke=
yword">and</span> isinstance(addr, str):
        bank, addr =3D self._lookup_symbol(addr)

    breakpoint_meta =3D self.mb.breakpoint_find(bank, addr)
    <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword">not=
</span> breakpoint_meta:
        <span class=3D"hljs-keyword">raise</span> ValueError(<span class=3D=
"hljs-string">"Breakpoint not found for bank and addr"</span>)
    _, _, opcode =3D breakpoint_meta

    self.mb.breakpoint_remove(bank, addr)
    bank_addr_opcode =3D (bank &amp; <span class=3D"hljs-number">0xFF</span=
>) &lt;&lt; <span class=3D"hljs-number">24</span> | (addr &amp; <span class=
=3D"hljs-number">0xFFFF</span>) &lt;&lt; <span class=3D"hljs-number">8</spa=
n> | (opcode &amp; <span class=3D"hljs-number">0xFF</span>)
    self._hooks.pop(bank_addr_opcode)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.get_sprite"><code class=3D"name flex">
<span>def <span class=3D"ident">get_sprite</span></span>(<span>self, sprite=
_index)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Provides a <code><a title=3D"pyboy.api.sprite.Sp=
rite" href=3D"https://docs.pyboy.dk/api/sprite.html#pyboy.api.sprite.Sprite=
">Sprite</a></code> object, which makes the OAM data more presentable. The =
given index
corresponds to index of the sprite in the "Object Attribute Memory" (OAM).<=
/p>
<p>The Game Boy supports 40 sprites in total. Read more details about it, i=
n the <a href=3D"http://bgb.bircd.org/pandocs.htm">Pan
Docs</a>.</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>s =3D pyboy.get_sprite(<span class=3D"hljs-number">12</span>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>s
Sprite [<span class=3D"hljs-number">12</span>]: Position: (<span class=3D"h=
ljs-number">-8</span>, <span class=3D"hljs-number">-16</span>), Shape: (<sp=
an class=3D"hljs-number">8</span>, <span class=3D"hljs-number">8</span>), T=
iles: (Tile: <span class=3D"hljs-number">0</span>), On screen: <span class=
=3D"hljs-keyword">False</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>s.on_screen
<span class=3D"hljs-keyword">False</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>s.tiles
[Tile: <span class=3D"hljs-number">0</span>]

</code></pre>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :=E2=80=82<code>int</code></dt>
<dd>Sprite index from 0 to 39.</dd>
</dl>
<h2 id=3D"returns">Returns</h2>
<p><code><a title=3D"pyboy.api.sprite.Sprite" href=3D"https://docs.pyboy.dk=
/api/sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code>:
Sprite corresponding to the given index.</p></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">get_sprite</span><s=
pan class=3D"hljs-params">(self, sprite_index)</span>:</span>
    <span class=3D"hljs-string">"""
    Provides a `pyboy.api.sprite.Sprite` object, which makes the OAM data m=
ore presentable. The given index
    corresponds to index of the sprite in the "Object Attribute Memory" (OA=
M).

    The Game Boy supports 40 sprites in total. Read more details about it, =
in the [Pan
    Docs](http://bgb.bircd.org/pandocs.htm).

    ```python
    &gt;&gt;&gt; s =3D pyboy.get_sprite(12)
    &gt;&gt;&gt; s
    Sprite [12]: Position: (-8, -16), Shape: (8, 8), Tiles: (Tile: 0), On s=
creen: False
    &gt;&gt;&gt; s.on_screen
    False
    &gt;&gt;&gt; s.tiles
    [Tile: 0]

    ```

    Args:
        index (int): Sprite index from 0 to 39.
    Returns
    -------
    `pyboy.api.sprite.Sprite`:
        Sprite corresponding to the given index.
    """</span>
    <span class=3D"hljs-keyword">return</span> Sprite(self.mb, sprite_index=
)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.get_sprite_by_tile_identifier"><code class=3D"name fl=
ex">
<span>def <span class=3D"ident">get_sprite_by_tile_identifier</span></span>=
(<span>self, tile_identifiers, on_screen=3DTrue)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>Provided a list of tile identifiers, this functi=
on will find all occurrences of sprites using the tile
identifiers and return the sprite indexes where each identifier is found. U=
se the sprite indexes in the
<code><a title=3D"pyboy.PyBoy.get_sprite" href=3D"https://docs.pyboy.dk/ind=
ex.html#pyboy.PyBoy.get_sprite">PyBoy.get_sprite()</a></code> function to g=
et a <code><a title=3D"pyboy.api.sprite.Sprite" href=3D"https://docs.pyboy.=
dk/api/sprite.html#pyboy.api.sprite.Sprite">Sprite</a></code> object.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>print(pyboy.get_sprite_by_tile_identifier([<span class=3D"hljs=
-number">43</span>, <span class=3D"hljs-number">123</span>]))
[[<span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">2</span=
>, <span class=3D"hljs-number">4</span>], []]

</code></pre>
<p>Meaning, that tile identifier <code>43</code> is found at the sprite ind=
exes: 0, 2, and 4, while tile identifier
<code>123</code> was not found anywhere.</p>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>identifiers</code></strong> :=E2=80=82<code>list</code></=
dt>
<dd>List of tile identifiers (int)</dd>
<dt><strong><code>on_screen</code></strong> :=E2=80=82<code>bool</code></dt=
>
<dd>Require that the matched sprite is on screen</dd>
</dl>
<h2 id=3D"returns">Returns</h2>
<dl>
<dt><code>list:</code></dt>
<dd>list of sprite matches for every tile identifier in the input</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">get_sprite_by_tile_=
identifier</span><span class=3D"hljs-params">(self, tile_identifiers, on_sc=
reen=3DTrue)</span>:</span>
    <span class=3D"hljs-string">"""
    Provided a list of tile identifiers, this function will find all occurr=
ences of sprites using the tile
    identifiers and return the sprite indexes where each identifier is foun=
d. Use the sprite indexes in the
    `pyboy.PyBoy.get_sprite` function to get a `pyboy.api.sprite.Sprite` ob=
ject.

    Example:
    ```python
    &gt;&gt;&gt; print(pyboy.get_sprite_by_tile_identifier([43, 123]))
    [[0, 2, 4], []]

    ```

    Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2=
, and 4, while tile identifier
    `123` was not found anywhere.

    Args:
        identifiers (list): List of tile identifiers (int)
        on_screen (bool): Require that the matched sprite is on screen

    Returns
    -------
    list:
        list of sprite matches for every tile identifier in the input
    """</span>

    matches =3D []
    <span class=3D"hljs-keyword">for</span> i <span class=3D"hljs-keyword">=
in</span> tile_identifiers:
        match =3D []
        <span class=3D"hljs-keyword">for</span> s <span class=3D"hljs-keywo=
rd">in</span> range(constants.SPRITES):
            sprite =3D Sprite(self.mb, s)
            <span class=3D"hljs-keyword">for</span> t <span class=3D"hljs-k=
eyword">in</span> sprite.tiles:
                <span class=3D"hljs-keyword">if</span> t.tile_identifier =
=3D=3D i <span class=3D"hljs-keyword">and</span> (<span class=3D"hljs-keywo=
rd">not</span> on_screen <span class=3D"hljs-keyword">or</span> (on_screen =
<span class=3D"hljs-keyword">and</span> sprite.on_screen)):
                    match.append(s)
        matches.append(match)
    <span class=3D"hljs-keyword">return</span> matches</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.get_tile"><code class=3D"name flex">
<span>def <span class=3D"ident">get_tile</span></span>(<span>self, identifi=
er)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>The Game Boy can have 384 tiles loaded in memory=
 at once (768 for Game Boy Color). Use this method to get a
<code><a title=3D"pyboy.api.tile.Tile" href=3D"https://docs.pyboy.dk/api/ti=
le.html#pyboy.api.tile.Tile">Tile</a></code>-object for given identifier.</=
p>
<p>The identifier is a PyBoy construct, which unifies two different scopes =
of indexes in the Game Boy hardware. See
the <code><a title=3D"pyboy.api.tile.Tile" href=3D"https://docs.pyboy.dk/ap=
i/tile.html#pyboy.api.tile.Tile">Tile</a></code> object for more informatio=
n.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>t =3D pyboy.get_tile(<span class=3D"hljs-number">2</span>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>t
Tile: <span class=3D"hljs-number">2</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>t.shape
(<span class=3D"hljs-number">8</span>, <span class=3D"hljs-number">8</span>=
)

</code></pre>
<h2 id=3D"returns">Returns</h2>
<p><code><a title=3D"pyboy.api.tile.Tile" href=3D"https://docs.pyboy.dk/api=
/tile.html#pyboy.api.tile.Tile">Tile</a></code>:
A Tile object for the given identifier.</p></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">get_tile</span><spa=
n class=3D"hljs-params">(self, identifier)</span>:</span>
    <span class=3D"hljs-string">"""
    The Game Boy can have 384 tiles loaded in memory at once (768 for Game =
Boy Color). Use this method to get a
    `pyboy.api.tile.Tile`-object for given identifier.

    The identifier is a PyBoy construct, which unifies two different scopes=
 of indexes in the Game Boy hardware. See
    the `pyboy.api.tile.Tile` object for more information.

    Example:
    ```python
    &gt;&gt;&gt; t =3D pyboy.get_tile(2)
    &gt;&gt;&gt; t
    Tile: 2
    &gt;&gt;&gt; t.shape
    (8, 8)

    ```

    Returns
    -------
    `pyboy.api.tile.Tile`:
        A Tile object for the given identifier.
    """</span>
    <span class=3D"hljs-keyword">return</span> Tile(self.mb, identifier=3Di=
dentifier)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoy.rtc_lock_experimental"><code class=3D"name flex">
<span>def <span class=3D"ident">rtc_lock_experimental</span></span>(<span>s=
elf, enable)</span>
</code></dt>
<dd>
<section class=3D"desc"><p><strong>WARN: This is an experimental API and is=
 subject to change.</strong></p>
<p>Lock the Real Time Clock (RTC) of a supporting cartridge. It might be ad=
vantageous to lock the RTC when training
an AI in games that use it to change behavior (i.e. day and night).</p>
<p>The first time the game is turned on, an <code>.rtc</code> file is creat=
ed with the current time. This is the epoch for the
RTC. When using <code>rtc_lock_experimental</code>, the RTC will always rep=
ort this point in time. If you let the game
progress first, before using <code>rtc_lock_experimental</code>, the intern=
al clock will move backwards and might corrupt
the game.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy =3D PyBoy(<span class=3D"hljs-string">'game_rom.gb'</spa=
n>)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.rtc_lock_experimental(<=
span class=3D"hljs-keyword">True</span>) <span class=3D"hljs-comment"># RTC=
 will not progress</span>
</code></pre>
<p><strong>WARN: This is an experimental API and is subject to change.</str=
ong></p>
<h2 id=3D"args">Args</h2>
<dl>
<dt><strong><code>enable</code></strong> :=E2=80=82<code>bool</code></dt>
<dd>True to lock RTC, False to operate normally</dd>
</dl></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-function"><span class=
=3D"hljs-keyword">def</span> <span class=3D"hljs-title">rtc_lock_experiment=
al</span><span class=3D"hljs-params">(self, enable)</span>:</span>
    <span class=3D"hljs-string">"""
    **WARN: This is an experimental API and is subject to change.**

    Lock the Real Time Clock (RTC) of a supporting cartridge. It might be a=
dvantageous to lock the RTC when training
    an AI in games that use it to change behavior (i.e. day and night).

    The first time the game is turned on, an `.rtc` file is created with th=
e current time. This is the epoch for the
    RTC. When using `rtc_lock_experimental`, the RTC will always report thi=
s point in time. If you let the game
    progress first, before using `rtc_lock_experimental`, the internal cloc=
k will move backwards and might corrupt
    the game.

    Example:
    ```python
    &gt;&gt;&gt; pyboy =3D PyBoy('game_rom.gb')
    &gt;&gt;&gt; pyboy.rtc_lock_experimental(True) # RTC will not progress
    ```

    **WARN: This is an experimental API and is subject to change.**

    Args:
        enable (bool): True to lock RTC, False to operate normally
    """</span>
    <span class=3D"hljs-keyword">if</span> self.mb.cartridge.rtc_enabled:
        self.mb.cartridge.rtc.timelock =3D enable
    <span class=3D"hljs-keyword">else</span>:
        <span class=3D"hljs-keyword">raise</span> Exception(<span class=3D"=
hljs-string">"There's no RTC for this cartridge type"</span>)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id=3D"pyboy.PyBoyMemoryView"><code class=3D"flex name class">
<span>class <span class=3D"ident">PyBoyMemoryView</span></span>
<span>(</span><span>mb)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>This class cannot be used directly, but is acces=
sed through <code><a title=3D"pyboy.PyBoy.memory" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoy.memory">PyBoy.memory</a></code>.</p>
<p>This class serves four purposes: Reading memory (ROM/RAM), writing memor=
y (ROM/RAM), overriding memory (ROM/RAM) and special registers.</p>
<p>See the <a href=3D"https://gbdev.io/pandocs/Memory_Map.html">Pan Docs: M=
emory Map</a> for a great overview of the memory space.</p>
<p>Memory can be accessed as individual bytes (<code>pyboy.memory[0x00]</co=
de>) or as slices (<code>pyboy.memory[0x00:0x10]</code>). And if
applicable, a specific ROM/RAM bank can be defined before the address (<cod=
e>pyboy.memory[0, 0x00]</code> or <code>pyboy.memory[0, 0x00:0x10]</code>).=
</p>
<p>The boot ROM is accessed using the special "-1" ROM bank.</p>
<p>The find addresses of interest, either search online for something like:=
 "[game title] RAM map", or find them yourself
using <code><a title=3D"pyboy.PyBoy.memory_scanner" href=3D"https://docs.py=
boy.dk/index.html#pyboy.PyBoy.memory_scanner">PyBoy.memory_scanner</a></cod=
e>.</p>
<p><strong>Read:</strong></p>
<p>If you're developing a bot or AI with this API, you're most likely going=
 to be using read the most. This is how you
would efficiently read the score, time, coins, positions etc. in a game's m=
emory.</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.memory[<span class=3D"hljs-number">0x0000</span>] <span =
class=3D"hljs-comment"># Read one byte at address 0x0000</span>
<span class=3D"hljs-number">49</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0x0000</span>:<span class=3D"hljs-number">0x0010</span>] <span =
class=3D"hljs-comment"># Read 16 bytes from 0x0000 to 0x0010 (excluding 0x0=
010)</span>
[<span class=3D"hljs-number">49</span>, <span class=3D"hljs-number">254</sp=
an>, <span class=3D"hljs-number">255</span>, <span class=3D"hljs-number">33=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
128</span>, <span class=3D"hljs-number">175</span>, <span class=3D"hljs-num=
ber">34</span>, <span class=3D"hljs-number">124</span>, <span class=3D"hljs=
-number">254</span>, <span class=3D"hljs-number">160</span>, <span class=3D=
"hljs-number">32</span>, <span class=3D"hljs-number">249</span>, <span clas=
s=3D"hljs-number">6</span>, <span class=3D"hljs-number">48</span>, <span cl=
ass=3D"hljs-number">33</span>]
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">-1</span>, <span class=3D"hljs-number">0x0000</span>:<span clas=
s=3D"hljs-number">0x0010</span>] <span class=3D"hljs-comment"># Read 16 byt=
es from 0x0000 to 0x0010 (excluding 0x0010) from the boot ROM</span>
[<span class=3D"hljs-number">49</span>, <span class=3D"hljs-number">254</sp=
an>, <span class=3D"hljs-number">255</span>, <span class=3D"hljs-number">33=
</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">=
128</span>, <span class=3D"hljs-number">175</span>, <span class=3D"hljs-num=
ber">34</span>, <span class=3D"hljs-number">124</span>, <span class=3D"hljs=
-number">254</span>, <span class=3D"hljs-number">160</span>, <span class=3D=
"hljs-number">32</span>, <span class=3D"hljs-number">249</span>, <span clas=
s=3D"hljs-number">6</span>, <span class=3D"hljs-number">48</span>, <span cl=
ass=3D"hljs-number">33</span>]
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0</span>, <span class=3D"hljs-number">0x0000</span>:<span class=
=3D"hljs-number">0x0010</span>] <span class=3D"hljs-comment"># Read 16 byte=
s from 0x0000 to 0x0010 (excluding 0x0010) from ROM bank 0</span>
[<span class=3D"hljs-number">64</span>, <span class=3D"hljs-number">65</spa=
n>, <span class=3D"hljs-number">66</span>, <span class=3D"hljs-number">67</=
span>, <span class=3D"hljs-number">68</span>, <span class=3D"hljs-number">6=
9</span>, <span class=3D"hljs-number">70</span>, <span class=3D"hljs-number=
">65</span>, <span class=3D"hljs-number">65</span>, <span class=3D"hljs-num=
ber">65</span>, <span class=3D"hljs-number">71</span>, <span class=3D"hljs-=
number">65</span>, <span class=3D"hljs-number">65</span>, <span class=3D"hl=
js-number">65</span>, <span class=3D"hljs-number">72</span>, <span class=3D=
"hljs-number">73</span>]
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">2</span>, <span class=3D"hljs-number">0xA000</span>] <span clas=
s=3D"hljs-comment"># Read from external RAM on cartridge (if any) from bank=
 2 at address 0xA000</span>
<span class=3D"hljs-number">0</span>
</code></pre>
<p><strong>Write:</strong></p>
<p>Writing to Game Boy memory can be complicated because of the limited add=
ress space. There's a lot of memory that
isn't directly accessible, and can be hidden through "memory banking". This=
 means that the same address range
(for example 0x4000 to 0x8000) can change depending on what state the game =
is in.</p>
<p>If you want to change an address in the ROM, then look at override below=
. Issuing writes to the ROM area actually
sends commands to the <a href=3D"https://gbdev.io/pandocs/MBCs.html#mbcs">M=
emory Bank Controller (MBC)</a> on the cartridge.</p>
<p>A write is done by assigning to the <code><a title=3D"pyboy.PyBoy.memory=
" href=3D"https://docs.pyboy.dk/index.html#pyboy.PyBoy.memory">PyBoy.memory=
</a></code> object. It's recommended to define the bank to avoid mistakes
(<code>pyboy.memory[2, 0xA000]=3D1</code>). Without defining the bank, PyBo=
y will pick the current bank for the given address if
needed (<code>pyboy.memory[0xA000]=3D1</code>).</p>
<p>At this point, all reads will return a new list of the values in the giv=
en range. The slices will not reference back to the PyBoy memory. This feat=
ure might come in the future.</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.memory[<span class=3D"hljs-number">0xC000</span>] =3D <s=
pan class=3D"hljs-number">123</span> <span class=3D"hljs-comment"># Write t=
o WRAM at address 0xC000</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0xC000</span>:<span class=3D"hljs-number">0xC00A</span>] =3D [<=
span class=3D"hljs-number">0</span>,<span class=3D"hljs-number">1</span>,<s=
pan class=3D"hljs-number">2</span>,<span class=3D"hljs-number">3</span>,<sp=
an class=3D"hljs-number">4</span>,<span class=3D"hljs-number">5</span>,<spa=
n class=3D"hljs-number">6</span>,<span class=3D"hljs-number">7</span>,<span=
 class=3D"hljs-number">8</span>,<span class=3D"hljs-number">9</span>] <span=
 class=3D"hljs-comment"># Write to WRAM from address 0xC000 to 0xC00A</span=
>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0xC010</span>:<span class=3D"hljs-number">0xC01A</span>] =3D <s=
pan class=3D"hljs-number">0</span> <span class=3D"hljs-comment"># Write to =
WRAM from address 0xC010 to 0xC01A</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0x1000</span>] =3D <span class=3D"hljs-number">123</span> <span=
 class=3D"hljs-comment"># Not writing 123 at address 0x1000! This sends a c=
ommand to the cartridge's MBC.</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">2</span>, <span class=3D"hljs-number">0xA000</span>] =3D <span =
class=3D"hljs-number">123</span> <span class=3D"hljs-comment"># Write to ex=
ternal RAM on cartridge (if any) for bank 2 at address 0xA000</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span><span class=3D"hljs-comment">=
# Game Boy Color (CGB) only:</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy_cgb.memory[<span class=
=3D"hljs-number">1</span>, <span class=3D"hljs-number">0x8000</span>] =3D <=
span class=3D"hljs-number">25</span> <span class=3D"hljs-comment"># Write t=
o VRAM bank 1 at address 0xD000 when in CGB mode</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy_cgb.memory[<span class=
=3D"hljs-number">6</span>, <span class=3D"hljs-number">0xD000</span>] =3D <=
span class=3D"hljs-number">25</span> <span class=3D"hljs-comment"># Write t=
o WRAM bank 6 at address 0xD000 when in CGB mode</span>
</code></pre>
<p><strong>Override:</strong></p>
<p>Override data at a given memory address of the Game Boy's ROM.</p>
<p>This can be used to reprogram a game ROM to change its behavior.</p>
<p>This will not let your override RAM or a special register. This will let=
 you override data in the ROM at any given bank.
This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000 ca=
n be changed from the MBC.</p>
<p><em>NOTE</em>: Any changes here are not saved or loaded to game states! =
Use this function with caution and reapply
any overrides when reloading the ROM.</p>
<p>To override, it's required to provide the ROM-bank you're changing. Othe=
rwise, it'll be considered a regular 'write' as described above.</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.memory[<span class=3D"hljs-number">0</span>, <span class=
=3D"hljs-number">0x0010</span>] =3D <span class=3D"hljs-number">10</span> <=
span class=3D"hljs-comment"># Override ROM-bank 0 at address 0x0010</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0</span>, <span class=3D"hljs-number">0x0010</span>:<span class=
=3D"hljs-number">0x001A</span>] =3D [<span class=3D"hljs-number">0</span>,<=
span class=3D"hljs-number">1</span>,<span class=3D"hljs-number">2</span>,<s=
pan class=3D"hljs-number">3</span>,<span class=3D"hljs-number">4</span>,<sp=
an class=3D"hljs-number">5</span>,<span class=3D"hljs-number">6</span>,<spa=
n class=3D"hljs-number">7</span>,<span class=3D"hljs-number">8</span>,<span=
 class=3D"hljs-number">9</span>] <span class=3D"hljs-comment"># Override RO=
M-bank 0 at address 0x0010 to 0x001A</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">-1</span>, <span class=3D"hljs-number">0x0010</span>] =3D <span=
 class=3D"hljs-number">10</span> <span class=3D"hljs-comment"># Override bo=
ot ROM at address 0x0010</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">1</span>, <span class=3D"hljs-number">0x6000</span>] =3D <span =
class=3D"hljs-number">12</span> <span class=3D"hljs-comment"># Override ROM=
-bank 1 at address 0x6000</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0x1000</span>] =3D <span class=3D"hljs-number">12</span> <span =
class=3D"hljs-comment"># This will not override, as there is no ROM bank as=
signed!</span>
</code></pre>
<p><strong>Special Registers:</strong></p>
<p>The Game Boy has a range of memory addresses known as <a href=3D"https:/=
/gbdev.io/pandocs/Hardware_Reg_List.html">hardware registers</a>. These con=
trol parts of the hardware like LCD,
Timer, DMA, serial and so on. Even though they might appear as regular RAM =
addresses, reading/writing these addresses
often results in special side-effects.</p>
<p>The <a href=3D"https://gbdev.io/pandocs/Timer_and_Divider_Registers.html=
#ff04--div-divider-register">DIV (0xFF04) register</a> for example provides=
 a number that increments 16 thousand times each second. This can be
used as a source of randomness in games. If you read the value, you'll get =
a pseudo-random number. But if you write
<em>any</em> value to the register, it'll reset to zero.</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span>pyboy.memory[<span class=3D"hljs-number">0xFF04</span>] <span =
class=3D"hljs-comment"># DIV register</span>
<span class=3D"hljs-number">163</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0xFF04</span>] =3D <span class=3D"hljs-number">123</span> <span=
 class=3D"hljs-comment"># Trying to write to it will always reset it to zer=
o</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.memory[<span class=3D"h=
ljs-number">0xFF04</span>]
<span class=3D"hljs-number">0</span>
</code></pre></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-class"><span class=3D"=
hljs-keyword">class</span> <span class=3D"hljs-title">PyBoyMemoryView</span=
>:</span>
    <span class=3D"hljs-string">"""
    This class cannot be used directly, but is accessed through `PyBoy.memo=
ry`.

    This class serves four purposes: Reading memory (ROM/RAM), writing memo=
ry (ROM/RAM), overriding memory (ROM/RAM) and special registers.

    See the [Pan Docs: Memory Map](https://gbdev.io/pandocs/Memory_Map.html=
) for a great overview of the memory space.

    Memory can be accessed as individual bytes (`pyboy.memory[0x00]`) or as=
 slices (`pyboy.memory[0x00:0x10]`). And if
    applicable, a specific ROM/RAM bank can be defined before the address (=
`pyboy.memory[0, 0x00]` or `pyboy.memory[0, 0x00:0x10]`).

    The boot ROM is accessed using the special "-1" ROM bank.

    The find addresses of interest, either search online for something like=
: "[game title] RAM map", or find them yourself
    using `PyBoy.memory_scanner`.

    **Read:**

    If you're developing a bot or AI with this API, you're most likely goin=
g to be using read the most. This is how you
    would efficiently read the score, time, coins, positions etc. in a game=
's memory.

    ```python
    &gt;&gt;&gt; pyboy.memory[0x0000] # Read one byte at address 0x0000
    49
    &gt;&gt;&gt; pyboy.memory[0x0000:0x0010] # Read 16 bytes from 0x0000 to=
 0x0010 (excluding 0x0010)
    [49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
    &gt;&gt;&gt; pyboy.memory[-1, 0x0000:0x0010] # Read 16 bytes from 0x000=
0 to 0x0010 (excluding 0x0010) from the boot ROM
    [49, 254, 255, 33, 0, 128, 175, 34, 124, 254, 160, 32, 249, 6, 48, 33]
    &gt;&gt;&gt; pyboy.memory[0, 0x0000:0x0010] # Read 16 bytes from 0x0000=
 to 0x0010 (excluding 0x0010) from ROM bank 0
    [64, 65, 66, 67, 68, 69, 70, 65, 65, 65, 71, 65, 65, 65, 72, 73]
    &gt;&gt;&gt; pyboy.memory[2, 0xA000] # Read from external RAM on cartri=
dge (if any) from bank 2 at address 0xA000
    0
    ```

    **Write:**

    Writing to Game Boy memory can be complicated because of the limited ad=
dress space. There's a lot of memory that
    isn't directly accessible, and can be hidden through "memory banking". =
This means that the same address range
    (for example 0x4000 to 0x8000) can change depending on what state the g=
ame is in.

    If you want to change an address in the ROM, then look at override belo=
w. Issuing writes to the ROM area actually
    sends commands to the [Memory Bank Controller (MBC)](https://gbdev.io/p=
andocs/MBCs.html#mbcs) on the cartridge.

    A write is done by assigning to the `PyBoy.memory` object. It's recomme=
nded to define the bank to avoid mistakes
    (`pyboy.memory[2, 0xA000]=3D1`). Without defining the bank, PyBoy will =
pick the current bank for the given address if
    needed (`pyboy.memory[0xA000]=3D1`).

    At this point, all reads will return a new list of the values in the gi=
ven range. The slices will not reference back to the PyBoy memory. This fea=
ture might come in the future.

    ```python
    &gt;&gt;&gt; pyboy.memory[0xC000] =3D 123 # Write to WRAM at address 0x=
C000
    &gt;&gt;&gt; pyboy.memory[0xC000:0xC00A] =3D [0,1,2,3,4,5,6,7,8,9] # Wr=
ite to WRAM from address 0xC000 to 0xC00A
    &gt;&gt;&gt; pyboy.memory[0xC010:0xC01A] =3D 0 # Write to WRAM from add=
ress 0xC010 to 0xC01A
    &gt;&gt;&gt; pyboy.memory[0x1000] =3D 123 # Not writing 123 at address =
0x1000! This sends a command to the cartridge's MBC.
    &gt;&gt;&gt; pyboy.memory[2, 0xA000] =3D 123 # Write to external RAM on=
 cartridge (if any) for bank 2 at address 0xA000
    &gt;&gt;&gt; # Game Boy Color (CGB) only:
    &gt;&gt;&gt; pyboy_cgb.memory[1, 0x8000] =3D 25 # Write to VRAM bank 1 =
at address 0xD000 when in CGB mode
    &gt;&gt;&gt; pyboy_cgb.memory[6, 0xD000] =3D 25 # Write to WRAM bank 6 =
at address 0xD000 when in CGB mode
    ```

    **Override:**

    Override data at a given memory address of the Game Boy's ROM.

    This can be used to reprogram a game ROM to change its behavior.

    This will not let your override RAM or a special register. This will le=
t you override data in the ROM at any given bank.
    This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x800=
0 can be changed from the MBC.

    _NOTE_: Any changes here are not saved or loaded to game states! Use th=
is function with caution and reapply
    any overrides when reloading the ROM.

    To override, it's required to provide the ROM-bank you're changing. Oth=
erwise, it'll be considered a regular 'write' as described above.

    ```python
    &gt;&gt;&gt; pyboy.memory[0, 0x0010] =3D 10 # Override ROM-bank 0 at ad=
dress 0x0010
    &gt;&gt;&gt; pyboy.memory[0, 0x0010:0x001A] =3D [0,1,2,3,4,5,6,7,8,9] #=
 Override ROM-bank 0 at address 0x0010 to 0x001A
    &gt;&gt;&gt; pyboy.memory[-1, 0x0010] =3D 10 # Override boot ROM at add=
ress 0x0010
    &gt;&gt;&gt; pyboy.memory[1, 0x6000] =3D 12 # Override ROM-bank 1 at ad=
dress 0x6000
    &gt;&gt;&gt; pyboy.memory[0x1000] =3D 12 # This will not override, as t=
here is no ROM bank assigned!
    ```

    **Special Registers:**

    The Game Boy has a range of memory addresses known as [hardware registe=
rs](https://gbdev.io/pandocs/Hardware_Reg_List.html). These control parts o=
f the hardware like LCD,
    Timer, DMA, serial and so on. Even though they might appear as regular =
RAM addresses, reading/writing these addresses
    often results in special side-effects.

    The [DIV (0xFF04) register](https://gbdev.io/pandocs/Timer_and_Divider_=
Registers.html#ff04--div-divider-register) for example provides a number th=
at increments 16 thousand times each second. This can be
    used as a source of randomness in games. If you read the value, you'll =
get a pseudo-random number. But if you write
    *any* value to the register, it'll reset to zero.

    ```python
    &gt;&gt;&gt; pyboy.memory[0xFF04] # DIV register
    163
    &gt;&gt;&gt; pyboy.memory[0xFF04] =3D 123 # Trying to write to it will =
always reset it to zero
    &gt;&gt;&gt; pyboy.memory[0xFF04]
    0
    ```

    """</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__init__</span><span class=3D"hljs-params">(self,=
 mb)</span>:</span>
        self.mb =3D mb

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">_fix_slice</span><span class=3D"hljs-params">(sel=
f, addr)</span>:</span>
        <span class=3D"hljs-keyword">if</span> addr.start <span class=3D"hl=
js-keyword">is</span> <span class=3D"hljs-keyword">None</span>:
            <span class=3D"hljs-keyword">return</span> (<span class=3D"hljs=
-number">-1</span>, <span class=3D"hljs-number">0</span>, <span class=3D"hl=
js-number">0</span>)
        <span class=3D"hljs-keyword">if</span> addr.stop <span class=3D"hlj=
s-keyword">is</span> <span class=3D"hljs-keyword">None</span>:
            <span class=3D"hljs-keyword">return</span> (<span class=3D"hljs=
-number">0</span>, <span class=3D"hljs-number">-1</span>, <span class=3D"hl=
js-number">0</span>)
        start =3D addr.start
        stop =3D addr.stop
        <span class=3D"hljs-keyword">if</span> start &gt; stop:
            <span class=3D"hljs-keyword">return</span> (<span class=3D"hljs=
-number">-1</span>, <span class=3D"hljs-number">-1</span>, <span class=3D"h=
ljs-number">0</span>)
        <span class=3D"hljs-keyword">if</span> addr.step <span class=3D"hlj=
s-keyword">is</span> <span class=3D"hljs-keyword">None</span>:
            step =3D <span class=3D"hljs-number">1</span>
        <span class=3D"hljs-keyword">else</span>:
            step =3D addr.step
        <span class=3D"hljs-keyword">return</span> start, stop, step

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__getitem__</span><span class=3D"hljs-params">(se=
lf, addr)</span>:</span>
        is_bank =3D isinstance(addr, tuple)
        bank =3D <span class=3D"hljs-number">0</span>
        <span class=3D"hljs-keyword">if</span> is_bank:
            bank, addr =3D addr
            <span class=3D"hljs-keyword">assert</span> isinstance(bank, int=
), <span class=3D"hljs-string">"Bank has to be integer. Slicing is not supp=
orted."</span>
        is_single =3D isinstance(addr, int)
        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword"=
>not</span> is_single:
            start, stop, step =3D self._fix_slice(addr)
            <span class=3D"hljs-keyword">assert</span> start &gt;=3D <span =
class=3D"hljs-number">0</span> <span class=3D"hljs-keyword">or</span> stop =
&gt;=3D <span class=3D"hljs-number">0</span>, <span class=3D"hljs-string">"=
Start address has to come before end address"</span>
            <span class=3D"hljs-keyword">assert</span> start &gt;=3D <span =
class=3D"hljs-number">0</span>, <span class=3D"hljs-string">"Start address =
required"</span>
            <span class=3D"hljs-keyword">assert</span> stop &gt;=3D <span c=
lass=3D"hljs-number">0</span>, <span class=3D"hljs-string">"End address req=
uired"</span>
            <span class=3D"hljs-keyword">return</span> self.__getitem(start=
, stop, step, bank, is_single, is_bank)
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-keyword">return</span> self.__getitem(addr,=
 <span class=3D"hljs-number">0</span>, <span class=3D"hljs-number">1</span>=
, bank, is_single, is_bank)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__getitem</span><span class=3D"hljs-params">(self=
, start, stop, step, bank, is_single, is_bank)</span>:</span>
        slice_length =3D (stop-start) // step
        <span class=3D"hljs-keyword">if</span> is_bank:
            <span class=3D"hljs-comment"># Reading a specific bank</span>
            <span class=3D"hljs-keyword">if</span> start &lt; <span class=
=3D"hljs-number">0x8000</span>:
                <span class=3D"hljs-keyword">if</span> start &gt;=3D <span =
class=3D"hljs-number">0x4000</span>:
                    start -=3D <span class=3D"hljs-number">0x4000</span>
                    stop -=3D <span class=3D"hljs-number">0x4000</span>
                <span class=3D"hljs-comment"># Cartridge ROM Banks</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x4000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading ROM bank"</span>
                <span class=3D"hljs-keyword">if</span> bank =3D=3D <span cl=
ass=3D"hljs-number">-1</span>:
                    <span class=3D"hljs-keyword">assert</span> start &lt;=
=3D <span class=3D"hljs-number">0xFF</span>, <span class=3D"hljs-string">"S=
tart address out of range for bootrom"</span>
                    <span class=3D"hljs-keyword">assert</span> stop &lt;=3D=
 <span class=3D"hljs-number">0xFF</span>, <span class=3D"hljs-string">"Star=
t address out of range for bootrom"</span>
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        mem_slice =3D [<span class=3D"hljs-number">0</span>=
] * slice_length
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            mem_slice[(x-start) // step] =3D self.mb.bootro=
m.bootrom[x]
                        <span class=3D"hljs-keyword">return</span> mem_slic=
e
                    <span class=3D"hljs-keyword">else</span>:
                        <span class=3D"hljs-keyword">return</span> self.mb.=
bootrom.bootrom[start]
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">assert</span> bank &lt;=3D=
 self.mb.cartridge.external_rom_count, <span class=3D"hljs-string">"ROM Ban=
k out of range"</span>
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        mem_slice =3D [<span class=3D"hljs-number">0</span>=
] * slice_length
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            mem_slice[(x-start) // step] =3D self.mb.cartri=
dge.rombanks[bank, x]
                        <span class=3D"hljs-keyword">return</span> mem_slic=
e
                    <span class=3D"hljs-keyword">else</span>:
                        <span class=3D"hljs-keyword">return</span> self.mb.=
cartridge.rombanks[bank, start]
            <span class=3D"hljs-keyword">elif</span> start &lt; <span class=
=3D"hljs-number">0xA000</span>:
                start -=3D <span class=3D"hljs-number">0x8000</span>
                stop -=3D <span class=3D"hljs-number">0x8000</span>
                <span class=3D"hljs-comment"># CGB VRAM Banks</span>
                <span class=3D"hljs-keyword">assert</span> self.mb.cgb <spa=
n class=3D"hljs-keyword">or</span> (bank =3D=3D <span class=3D"hljs-number"=
>0</span>), <span class=3D"hljs-string">"Selecting bank of VRAM is only sup=
ported for CGB mode"</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x2000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading VRAM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D <sp=
an class=3D"hljs-number">1</span>, <span class=3D"hljs-string">"VRAM Bank o=
ut of range"</span>

                <span class=3D"hljs-keyword">if</span> bank =3D=3D <span cl=
ass=3D"hljs-number">0</span>:
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        mem_slice =3D [<span class=3D"hljs-number">0</span>=
] * slice_length
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            mem_slice[(x-start) // step] =3D self.mb.lcd.VR=
AM0[x]
                        <span class=3D"hljs-keyword">return</span> mem_slic=
e
                    <span class=3D"hljs-keyword">else</span>:
                        <span class=3D"hljs-keyword">return</span> self.mb.=
lcd.VRAM0[start]
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        mem_slice =3D [<span class=3D"hljs-number">0</span>=
] * slice_length
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            mem_slice[(x-start) // step] =3D self.mb.lcd.VR=
AM1[x]
                        <span class=3D"hljs-keyword">return</span> mem_slic=
e
                    <span class=3D"hljs-keyword">else</span>:
                        <span class=3D"hljs-keyword">return</span> self.mb.=
lcd.VRAM1[start]
            <span class=3D"hljs-keyword">elif</span> start &lt; <span class=
=3D"hljs-number">0xC000</span>:
                start -=3D <span class=3D"hljs-number">0xA000</span>
                stop -=3D <span class=3D"hljs-number">0xA000</span>
                <span class=3D"hljs-comment"># Cartridge RAM banks</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x2000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading cartridge RAM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D sel=
f.mb.cartridge.external_ram_count, <span class=3D"hljs-string">"ROM Bank ou=
t of range"</span>
                <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-=
keyword">not</span> is_single:
                    mem_slice =3D [<span class=3D"hljs-number">0</span>] * =
slice_length
                    <span class=3D"hljs-keyword">for</span> x <span class=
=3D"hljs-keyword">in</span> range(start, stop, step):
                        mem_slice[(x-start) // step] =3D self.mb.cartridge.=
rambanks[bank, x]
                    <span class=3D"hljs-keyword">return</span> mem_slice
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">return</span> self.mb.cart=
ridge.rambanks[bank, start]
            <span class=3D"hljs-keyword">elif</span> start &lt; <span class=
=3D"hljs-number">0xE000</span>:
                start -=3D <span class=3D"hljs-number">0xC000</span>
                stop -=3D <span class=3D"hljs-number">0xC000</span>
                <span class=3D"hljs-keyword">if</span> start &gt;=3D <span =
class=3D"hljs-number">0x1000</span>:
                    start -=3D <span class=3D"hljs-number">0x1000</span>
                    stop -=3D <span class=3D"hljs-number">0x1000</span>
                <span class=3D"hljs-comment"># CGB VRAM banks</span>
                <span class=3D"hljs-keyword">assert</span> self.mb.cgb <spa=
n class=3D"hljs-keyword">or</span> (bank =3D=3D <span class=3D"hljs-number"=
>0</span>), <span class=3D"hljs-string">"Selecting bank of WRAM is only sup=
ported for CGB mode"</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x1000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading VRAM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D <sp=
an class=3D"hljs-number">7</span>, <span class=3D"hljs-string">"WRAM Bank o=
ut of range"</span>
                <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-=
keyword">not</span> is_single:
                    mem_slice =3D [<span class=3D"hljs-number">0</span>] * =
slice_length
                    <span class=3D"hljs-keyword">for</span> x <span class=
=3D"hljs-keyword">in</span> range(start, stop, step):
                        mem_slice[(x-start) // step] =3D self.mb.ram.intern=
al_ram0[x + bank*<span class=3D"hljs-number">0x1000</span>]
                    <span class=3D"hljs-keyword">return</span> mem_slice
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">return</span> self.mb.ram.=
internal_ram0[start + bank*<span class=3D"hljs-number">0x1000</span>]
            <span class=3D"hljs-keyword">else</span>:
                <span class=3D"hljs-keyword">assert</span> <span class=3D"h=
ljs-keyword">None</span>, <span class=3D"hljs-string">"Invalid memory addre=
ss for bank"</span>
        <span class=3D"hljs-keyword">elif</span> <span class=3D"hljs-keywor=
d">not</span> is_single:
            <span class=3D"hljs-comment"># Reading slice of memory space</s=
pan>
            mem_slice =3D [<span class=3D"hljs-number">0</span>] * slice_le=
ngth
            <span class=3D"hljs-keyword">for</span> x <span class=3D"hljs-k=
eyword">in</span> range(start, stop, step):
                mem_slice[(x-start) // step] =3D self.mb.getitem(x)
            <span class=3D"hljs-keyword">return</span> mem_slice
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-comment"># Reading specific address of memo=
ry space</span>
            <span class=3D"hljs-keyword">return</span> self.mb.getitem(star=
t)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__setitem__</span><span class=3D"hljs-params">(se=
lf, addr, v)</span>:</span>
        is_bank =3D isinstance(addr, tuple)
        bank =3D <span class=3D"hljs-number">0</span>
        <span class=3D"hljs-keyword">if</span> is_bank:
            bank, addr =3D addr
            <span class=3D"hljs-keyword">assert</span> isinstance(bank, int=
), <span class=3D"hljs-string">"Bank has to be integer. Slicing is not supp=
orted."</span>
        is_single =3D isinstance(addr, int)
        <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-keyword"=
>not</span> is_single:
            start, stop, step =3D self._fix_slice(addr)
            <span class=3D"hljs-keyword">assert</span> start &gt;=3D <span =
class=3D"hljs-number">0</span>, <span class=3D"hljs-string">"Start address =
required"</span>
            <span class=3D"hljs-keyword">assert</span> stop &gt;=3D <span c=
lass=3D"hljs-number">0</span>, <span class=3D"hljs-string">"End address req=
uired"</span>
            self.__setitem(start, stop, step, v, bank, is_single, is_bank)
        <span class=3D"hljs-keyword">else</span>:
            self.__setitem(addr, <span class=3D"hljs-number">0</span>, <spa=
n class=3D"hljs-number">0</span>, v, bank, is_single, is_bank)

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__setitem</span><span class=3D"hljs-params">(self=
, start, stop, step, v, bank, is_single, is_bank)</span>:</span>
        <span class=3D"hljs-keyword">if</span> is_bank:
            <span class=3D"hljs-comment"># Writing a specific bank</span>
            <span class=3D"hljs-keyword">if</span> start &lt; <span class=
=3D"hljs-number">0x8000</span>:
                <span class=3D"hljs-string">"""
                Override one byte at a given memory address of the Game Boy=
's ROM.

                This will let you override data in the ROM at any given ban=
k. This is the memory allocated at 0x0000 to 0x8000, where 0x4000 to 0x8000=
 can be changed from the MBC.

                __NOTE__: Any changes here are not saved or loaded to game =
states! Use this function with caution and reapply
                any overrides when reloading the ROM.

                If you need to change a RAM address, see `pyboy.PyBoy.memor=
y`.

                Args:
                    rom_bank (int): ROM bank to do the overwrite in
                    addr (int): Address to write the byte inside the ROM ba=
nk
                    value (int): A byte of data
                """</span>
                <span class=3D"hljs-keyword">if</span> start &gt;=3D <span =
class=3D"hljs-number">0x4000</span>:
                    start -=3D <span class=3D"hljs-number">0x4000</span>
                    stop -=3D <span class=3D"hljs-number">0x4000</span>
                <span class=3D"hljs-comment"># Cartridge ROM Banks</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x4000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading ROM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D sel=
f.mb.cartridge.external_rom_count, <span class=3D"hljs-string">"ROM Bank ou=
t of range"</span>

                <span class=3D"hljs-comment"># <span class=3D"hljs-doctag">=
TODO:</span> If you change a RAM value outside of the ROM banks above, the =
memory value will stay the same no matter</span>
                <span class=3D"hljs-comment"># what the game writes to the =
address. This can be used so freeze the value for health, cash etc.</span>
                <span class=3D"hljs-keyword">if</span> bank =3D=3D <span cl=
ass=3D"hljs-number">-1</span>:
                    <span class=3D"hljs-keyword">assert</span> start &lt;=
=3D <span class=3D"hljs-number">0xFF</span>, <span class=3D"hljs-string">"S=
tart address out of range for bootrom"</span>
                    <span class=3D"hljs-keyword">assert</span> stop &lt;=3D=
 <span class=3D"hljs-number">0xFF</span>, <span class=3D"hljs-string">"Star=
t address out of range for bootrom"</span>
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        <span class=3D"hljs-comment"># Writing slice of mem=
ory space</span>
                        <span class=3D"hljs-keyword">if</span> hasattr(v, <=
span class=3D"hljs-string">"__iter__"</span>):
                            <span class=3D"hljs-keyword">assert</span> (sto=
p-start) // step =3D=3D len(v), <span class=3D"hljs-string">"slice does not=
 match length of data"</span>
                            _v =3D iter(v)
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.bootrom.bootrom[x] =3D next(_v)
                        <span class=3D"hljs-keyword">else</span>:
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.bootrom.bootrom[x] =3D v
                    <span class=3D"hljs-keyword">else</span>:
                        self.mb.bootrom.bootrom[start] =3D v
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        <span class=3D"hljs-comment"># Writing slice of mem=
ory space</span>
                        <span class=3D"hljs-keyword">if</span> hasattr(v, <=
span class=3D"hljs-string">"__iter__"</span>):
                            <span class=3D"hljs-keyword">assert</span> (sto=
p-start) // step =3D=3D len(v), <span class=3D"hljs-string">"slice does not=
 match length of data"</span>
                            _v =3D iter(v)
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.cartridge.overrideitem(bank, x, nex=
t(_v))
                        <span class=3D"hljs-keyword">else</span>:
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.cartridge.overrideitem(bank, x, v)
                    <span class=3D"hljs-keyword">else</span>:
                        self.mb.cartridge.overrideitem(bank, start, v)

            <span class=3D"hljs-keyword">elif</span> start &lt; <span class=
=3D"hljs-number">0xA000</span>:
                start -=3D <span class=3D"hljs-number">0x8000</span>
                stop -=3D <span class=3D"hljs-number">0x8000</span>
                <span class=3D"hljs-comment"># CGB VRAM Banks</span>
                <span class=3D"hljs-keyword">assert</span> self.mb.cgb <spa=
n class=3D"hljs-keyword">or</span> (bank =3D=3D <span class=3D"hljs-number"=
>0</span>), <span class=3D"hljs-string">"Selecting bank of VRAM is only sup=
ported for CGB mode"</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x2000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading VRAM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D <sp=
an class=3D"hljs-number">1</span>, <span class=3D"hljs-string">"VRAM Bank o=
ut of range"</span>

                <span class=3D"hljs-keyword">if</span> bank =3D=3D <span cl=
ass=3D"hljs-number">0</span>:
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        <span class=3D"hljs-comment"># Writing slice of mem=
ory space</span>
                        <span class=3D"hljs-keyword">if</span> hasattr(v, <=
span class=3D"hljs-string">"__iter__"</span>):
                            <span class=3D"hljs-keyword">assert</span> (sto=
p-start) // step =3D=3D len(v), <span class=3D"hljs-string">"slice does not=
 match length of data"</span>
                            _v =3D iter(v)
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.lcd.VRAM0[x] =3D next(_v)
                        <span class=3D"hljs-keyword">else</span>:
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.lcd.VRAM0[x] =3D v
                    <span class=3D"hljs-keyword">else</span>:
                        self.mb.lcd.VRAM0[start] =3D v
                <span class=3D"hljs-keyword">else</span>:
                    <span class=3D"hljs-keyword">if</span> <span class=3D"h=
ljs-keyword">not</span> is_single:
                        <span class=3D"hljs-comment"># Writing slice of mem=
ory space</span>
                        <span class=3D"hljs-keyword">if</span> hasattr(v, <=
span class=3D"hljs-string">"__iter__"</span>):
                            <span class=3D"hljs-keyword">assert</span> (sto=
p-start) // step =3D=3D len(v), <span class=3D"hljs-string">"slice does not=
 match length of data"</span>
                            _v =3D iter(v)
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.lcd.VRAM1[x] =3D next(_v)
                        <span class=3D"hljs-keyword">else</span>:
                            <span class=3D"hljs-keyword">for</span> x <span=
 class=3D"hljs-keyword">in</span> range(start, stop, step):
                                self.mb.lcd.VRAM1[x] =3D v
                    <span class=3D"hljs-keyword">else</span>:
                        self.mb.lcd.VRAM1[start] =3D v
            <span class=3D"hljs-keyword">elif</span> start &lt; <span class=
=3D"hljs-number">0xC000</span>:
                start -=3D <span class=3D"hljs-number">0xA000</span>
                stop -=3D <span class=3D"hljs-number">0xA000</span>
                <span class=3D"hljs-comment"># Cartridge RAM banks</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x2000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading cartridge RAM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D sel=
f.mb.cartridge.external_ram_count, <span class=3D"hljs-string">"ROM Bank ou=
t of range"</span>
                <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-=
keyword">not</span> is_single:
                    <span class=3D"hljs-comment"># Writing slice of memory =
space</span>
                    <span class=3D"hljs-keyword">if</span> hasattr(v, <span=
 class=3D"hljs-string">"__iter__"</span>):
                        <span class=3D"hljs-keyword">assert</span> (stop-st=
art) // step =3D=3D len(v), <span class=3D"hljs-string">"slice does not mat=
ch length of data"</span>
                        _v =3D iter(v)
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            self.mb.cartridge.rambanks[bank, x] =3D next(_v=
)
                    <span class=3D"hljs-keyword">else</span>:
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            self.mb.cartridge.rambanks[bank, x] =3D v
                <span class=3D"hljs-keyword">else</span>:
                    self.mb.cartridge.rambanks[bank, start] =3D v
            <span class=3D"hljs-keyword">elif</span> start &lt; <span class=
=3D"hljs-number">0xE000</span>:
                start -=3D <span class=3D"hljs-number">0xC000</span>
                stop -=3D <span class=3D"hljs-number">0xC000</span>
                <span class=3D"hljs-keyword">if</span> start &gt;=3D <span =
class=3D"hljs-number">0x1000</span>:
                    start -=3D <span class=3D"hljs-number">0x1000</span>
                    stop -=3D <span class=3D"hljs-number">0x1000</span>
                <span class=3D"hljs-comment"># CGB VRAM banks</span>
                <span class=3D"hljs-keyword">assert</span> self.mb.cgb <spa=
n class=3D"hljs-keyword">or</span> (bank =3D=3D <span class=3D"hljs-number"=
>0</span>), <span class=3D"hljs-string">"Selecting bank of WRAM is only sup=
ported for CGB mode"</span>
                <span class=3D"hljs-keyword">assert</span> stop &lt; <span =
class=3D"hljs-number">0x1000</span>, <span class=3D"hljs-string">"Out of bo=
unds for reading VRAM bank"</span>
                <span class=3D"hljs-keyword">assert</span> bank &lt;=3D <sp=
an class=3D"hljs-number">7</span>, <span class=3D"hljs-string">"WRAM Bank o=
ut of range"</span>
                <span class=3D"hljs-keyword">if</span> <span class=3D"hljs-=
keyword">not</span> is_single:
                    <span class=3D"hljs-comment"># Writing slice of memory =
space</span>
                    <span class=3D"hljs-keyword">if</span> hasattr(v, <span=
 class=3D"hljs-string">"__iter__"</span>):
                        <span class=3D"hljs-keyword">assert</span> (stop-st=
art) // step =3D=3D len(v), <span class=3D"hljs-string">"slice does not mat=
ch length of data"</span>
                        _v =3D iter(v)
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            self.mb.ram.internal_ram0[x + bank*<span class=
=3D"hljs-number">0x1000</span>] =3D next(_v)
                    <span class=3D"hljs-keyword">else</span>:
                        <span class=3D"hljs-keyword">for</span> x <span cla=
ss=3D"hljs-keyword">in</span> range(start, stop, step):
                            self.mb.ram.internal_ram0[x + bank*<span class=
=3D"hljs-number">0x1000</span>] =3D v
                <span class=3D"hljs-keyword">else</span>:
                    self.mb.ram.internal_ram0[start + bank*<span class=3D"h=
ljs-number">0x1000</span>] =3D v
            <span class=3D"hljs-keyword">else</span>:
                <span class=3D"hljs-keyword">assert</span> <span class=3D"h=
ljs-keyword">None</span>, <span class=3D"hljs-string">"Invalid memory addre=
ss for bank"</span>
        <span class=3D"hljs-keyword">elif</span> <span class=3D"hljs-keywor=
d">not</span> is_single:
            <span class=3D"hljs-comment"># Writing slice of memory space</s=
pan>
            <span class=3D"hljs-keyword">if</span> hasattr(v, <span class=
=3D"hljs-string">"__iter__"</span>):
                <span class=3D"hljs-keyword">assert</span> (stop-start) // =
step =3D=3D len(v), <span class=3D"hljs-string">"slice does not match lengt=
h of data"</span>
                _v =3D iter(v)
                <span class=3D"hljs-keyword">for</span> x <span class=3D"hl=
js-keyword">in</span> range(start, stop, step):
                    self.mb.setitem(x, next(_v))
            <span class=3D"hljs-keyword">else</span>:
                <span class=3D"hljs-keyword">for</span> x <span class=3D"hl=
js-keyword">in</span> range(start, stop, step):
                    self.mb.setitem(x, v)
        <span class=3D"hljs-keyword">else</span>:
            <span class=3D"hljs-comment"># Writing specific address of memo=
ry space</span>
            self.mb.setitem(start, v)</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile"><code class=3D"flex name class">
<span>class <span class=3D"ident">PyBoyRegisterFile</span></span>
<span>(</span><span>cpu)</span>
</code></dt>
<dd>
<section class=3D"desc"><p>This class cannot be used directly, but is acces=
sed through <code><a title=3D"pyboy.PyBoy.register_file" href=3D"https://do=
cs.pyboy.dk/index.html#pyboy.PyBoy.register_file">PyBoy.register_file</a></=
code>.</p>
<p>This class serves the purpose of reading and writing to the CPU register=
s. It's best used inside the callback of a
hook, as <code><a title=3D"pyboy.PyBoy.tick" href=3D"https://docs.pyboy.dk/=
index.html#pyboy.PyBoy.tick">PyBoy.tick()</a></code> doesn't return at a sp=
ecific point.</p>
<p>See the <a href=3D"https://gbdev.io/pandocs/CPU_Registers_and_Flags.html=
">Pan Docs: CPU registers and flags</a> for a great overview.</p>
<p>Registers are accessed with the following names: <code>A, F, B, C, D, E,=
 HL, SP, PC</code> where the last three are 16-bit and
the others are 8-bit. Trying to write a number larger than 8 or 16 bits wil=
l truncate it.</p>
<p>Example:</p>
<pre><code class=3D"language-python hljs"><span class=3D"hljs-meta">&gt;&gt=
;&gt; </span><span class=3D"hljs-function"><span class=3D"hljs-keyword">def=
</span> <span class=3D"hljs-title">my_callback</span><span class=3D"hljs-pa=
rams">(pyboy)</span>:</span>
<span class=3D"hljs-meta">... </span>    print(<span class=3D"hljs-string">=
"Register A:"</span>, pyboy.register_file.A)
<span class=3D"hljs-meta">... </span>    pyboy.memory[<span class=3D"hljs-n=
umber">0xFF50</span>] =3D <span class=3D"hljs-number">1</span> <span class=
=3D"hljs-comment"># Example: Disable boot ROM</span>
<span class=3D"hljs-meta">... </span>    pyboy.register_file.A =3D <span cl=
ass=3D"hljs-number">0x11</span> <span class=3D"hljs-comment"># Modify to th=
e needed value</span>
<span class=3D"hljs-meta">... </span>    pyboy.register_file.PC =3D <span c=
lass=3D"hljs-number">0x100</span> <span class=3D"hljs-comment"># Jump past =
existing code</span>
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.hook_register(<span cla=
ss=3D"hljs-number">-1</span>, <span class=3D"hljs-number">0xFC</span>, my_c=
allback, pyboy)
<span class=3D"hljs-meta">&gt;&gt;&gt; </span>pyboy.tick(<span class=3D"hlj=
s-number">120</span>)
Register A: <span class=3D"hljs-number">1</span>
<span class=3D"hljs-keyword">True</span>
</code></pre></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-class"><span class=3D"=
hljs-keyword">class</span> <span class=3D"hljs-title">PyBoyRegisterFile</sp=
an>:</span>
    <span class=3D"hljs-string">"""
    This class cannot be used directly, but is accessed through `PyBoy.regi=
ster_file`.

    This class serves the purpose of reading and writing to the CPU registe=
rs. It's best used inside the callback of a
    hook, as `PyBoy.tick` doesn't return at a specific point.

    See the [Pan Docs: CPU registers and flags](https://gbdev.io/pandocs/CP=
U_Registers_and_Flags.html) for a great overview.

    Registers are accessed with the following names: `A, F, B, C, D, E, HL,=
 SP, PC` where the last three are 16-bit and
    the others are 8-bit. Trying to write a number larger than 8 or 16 bits=
 will truncate it.

    Example:
    ```python
    &gt;&gt;&gt; def my_callback(pyboy):
    ...     print("Register A:", pyboy.register_file.A)
    ...     pyboy.memory[0xFF50] =3D 1 # Example: Disable boot ROM
    ...     pyboy.register_file.A =3D 0x11 # Modify to the needed value
    ...     pyboy.register_file.PC =3D 0x100 # Jump past existing code
    &gt;&gt;&gt; pyboy.hook_register(-1, 0xFC, my_callback, pyboy)
    &gt;&gt;&gt; pyboy.tick(120)
    Register A: 1
    True
    ```
    """</span>

    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">__init__</span><span class=3D"hljs-params">(self,=
 cpu)</span>:</span>
        self.cpu =3D cpu

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">A</span><span class=3D"hljs-params">(self)</span>=
:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.A
<span class=3D"hljs-meta">    @A.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">A</span><span class=3D"hljs-params">(self, value)=
</span>:</span>
        self.cpu.A =3D value &amp; <span class=3D"hljs-number">0xFF</span>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">F</span><span class=3D"hljs-params">(self)</span>=
:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.F
<span class=3D"hljs-meta">    @F.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">F</span><span class=3D"hljs-params">(self, value)=
</span>:</span>
        self.cpu.F =3D value &amp; <span class=3D"hljs-number">0xF0</span>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">B</span><span class=3D"hljs-params">(self)</span>=
:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.B
<span class=3D"hljs-meta">    @B.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">B</span><span class=3D"hljs-params">(self, value)=
</span>:</span>
        self.cpu.B =3D value &amp; <span class=3D"hljs-number">0xFF</span>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">C</span><span class=3D"hljs-params">(self)</span>=
:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.C
<span class=3D"hljs-meta">    @C.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">C</span><span class=3D"hljs-params">(self, value)=
</span>:</span>
        self.cpu.C =3D value &amp; <span class=3D"hljs-number">0xFF</span>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">D</span><span class=3D"hljs-params">(self)</span>=
:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.D
<span class=3D"hljs-meta">    @D.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">D</span><span class=3D"hljs-params">(self, value)=
</span>:</span>
        self.cpu.D =3D value &amp; <span class=3D"hljs-number">0xFF</span>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">E</span><span class=3D"hljs-params">(self)</span>=
:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.E
<span class=3D"hljs-meta">    @E.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">E</span><span class=3D"hljs-params">(self, value)=
</span>:</span>
        self.cpu.E =3D value &amp; <span class=3D"hljs-number">0xFF</span>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">HL</span><span class=3D"hljs-params">(self)</span=
>:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.HL
<span class=3D"hljs-meta">    @HL.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">HL</span><span class=3D"hljs-params">(self, value=
)</span>:</span>
        self.cpu.HL =3D value &amp; <span class=3D"hljs-number">0xFFFF</spa=
n>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">SP</span><span class=3D"hljs-params">(self)</span=
>:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.SP
<span class=3D"hljs-meta">    @SP.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">SP</span><span class=3D"hljs-params">(self, value=
)</span>:</span>
        self.cpu.SP =3D value &amp; <span class=3D"hljs-number">0xFFFF</spa=
n>

<span class=3D"hljs-meta">    @property</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">PC</span><span class=3D"hljs-params">(self)</span=
>:</span>
        <span class=3D"hljs-keyword">return</span> self.cpu.PC
<span class=3D"hljs-meta">    @PC.setter</span>
    <span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <=
span class=3D"hljs-title">PC</span><span class=3D"hljs-params">(self, value=
)</span>:</span>
        self.cpu.PC =3D value &amp; <span class=3D"hljs-number">0xFFFF</spa=
n></code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id=3D"pyboy.PyBoyRegisterFile.A"><code class=3D"name">var <span class=
=3D"ident">A</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">A</span><span class=3D"hljs-params">(self)</span>:</s=
pan>
    <span class=3D"hljs-keyword">return</span> self.cpu.A</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.F"><code class=3D"name">var <span class=
=3D"ident">F</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">F</span><span class=3D"hljs-params">(self)</span>:</s=
pan>
    <span class=3D"hljs-keyword">return</span> self.cpu.F</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.B"><code class=3D"name">var <span class=
=3D"ident">B</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">B</span><span class=3D"hljs-params">(self)</span>:</s=
pan>
    <span class=3D"hljs-keyword">return</span> self.cpu.B</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.C"><code class=3D"name">var <span class=
=3D"ident">C</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">C</span><span class=3D"hljs-params">(self)</span>:</s=
pan>
    <span class=3D"hljs-keyword">return</span> self.cpu.C</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.D"><code class=3D"name">var <span class=
=3D"ident">D</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">D</span><span class=3D"hljs-params">(self)</span>:</s=
pan>
    <span class=3D"hljs-keyword">return</span> self.cpu.D</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.E"><code class=3D"name">var <span class=
=3D"ident">E</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">E</span><span class=3D"hljs-params">(self)</span>:</s=
pan>
    <span class=3D"hljs-keyword">return</span> self.cpu.E</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.HL"><code class=3D"name">var <span class=
=3D"ident">HL</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">HL</span><span class=3D"hljs-params">(self)</span>:</=
span>
    <span class=3D"hljs-keyword">return</span> self.cpu.HL</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.SP"><code class=3D"name">var <span class=
=3D"ident">SP</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">SP</span><span class=3D"hljs-params">(self)</span>:</=
span>
    <span class=3D"hljs-keyword">return</span> self.cpu.SP</code></pre>
</details>
</dd>
<dt id=3D"pyboy.PyBoyRegisterFile.PC"><code class=3D"name">var <span class=
=3D"ident">PC</span></code></dt>
<dd>
<section class=3D"desc"></section>
<details class=3D"source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class=3D"python hljs"><span class=3D"hljs-meta">@property</span>
<span class=3D"hljs-function"><span class=3D"hljs-keyword">def</span> <span=
 class=3D"hljs-title">PC</span><span class=3D"hljs-params">(self)</span>:</=
span>
    <span class=3D"hljs-keyword">return</span> self.cpu.PC</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id=3D"sidebar">
<h1>Index</h1>
<div class=3D"toc">
<ul></ul>
</div>
<ul id=3D"index">
<li><h3><a href=3D"https://docs.pyboy.dk/index.html#header-submodules">Sub-=
modules</a></h3>
<ul>
<li><code><a title=3D"pyboy.api" href=3D"https://docs.pyboy.dk/api/index.ht=
ml">pyboy.api</a></code></li>
<li><code><a title=3D"pyboy.plugins" href=3D"https://docs.pyboy.dk/plugins/=
index.html">pyboy.plugins</a></code></li>
<li><code><a title=3D"pyboy.utils" href=3D"https://docs.pyboy.dk/utils.html=
">pyboy.utils</a></code></li>
</ul>
</li>
<li><h3><a href=3D"https://docs.pyboy.dk/index.html#header-classes">Classes=
</a></h3>
<ul>
<li>
<h4><code><a title=3D"pyboy.PyBoy" href=3D"https://docs.pyboy.dk/index.html=
#pyboy.PyBoy">PyBoy</a></code></h4>
<ul class=3D"">
<li><code><a title=3D"pyboy.PyBoy.tick" href=3D"https://docs.pyboy.dk/index=
.html#pyboy.PyBoy.tick">tick</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.stop" href=3D"https://docs.pyboy.dk/index=
.html#pyboy.PyBoy.stop">stop</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.button" href=3D"https://docs.pyboy.dk/ind=
ex.html#pyboy.PyBoy.button">button</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.button_press" href=3D"https://docs.pyboy.=
dk/index.html#pyboy.PyBoy.button_press">button_press</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.button_release" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoy.button_release">button_release</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.send_input" href=3D"https://docs.pyboy.dk=
/index.html#pyboy.PyBoy.send_input">send_input</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.save_state" href=3D"https://docs.pyboy.dk=
/index.html#pyboy.PyBoy.save_state">save_state</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.load_state" href=3D"https://docs.pyboy.dk=
/index.html#pyboy.PyBoy.load_state">load_state</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.game_area_dimensions" href=3D"https://doc=
s.pyboy.dk/index.html#pyboy.PyBoy.game_area_dimensions">game_area_dimension=
s</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.game_area_collision" href=3D"https://docs=
.pyboy.dk/index.html#pyboy.PyBoy.game_area_collision">game_area_collision</=
a></code></li>
<li><code><a title=3D"pyboy.PyBoy.game_area_mapping" href=3D"https://docs.p=
yboy.dk/index.html#pyboy.PyBoy.game_area_mapping">game_area_mapping</a></co=
de></li>
<li><code><a title=3D"pyboy.PyBoy.game_area" href=3D"https://docs.pyboy.dk/=
index.html#pyboy.PyBoy.game_area">game_area</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.set_emulation_speed" href=3D"https://docs=
.pyboy.dk/index.html#pyboy.PyBoy.set_emulation_speed">set_emulation_speed</=
a></code></li>
<li><code><a title=3D"pyboy.PyBoy.symbol_lookup" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoy.symbol_lookup">symbol_lookup</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.hook_register" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoy.hook_register">hook_register</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.hook_deregister" href=3D"https://docs.pyb=
oy.dk/index.html#pyboy.PyBoy.hook_deregister">hook_deregister</a></code></l=
i>
<li><code><a title=3D"pyboy.PyBoy.get_sprite" href=3D"https://docs.pyboy.dk=
/index.html#pyboy.PyBoy.get_sprite">get_sprite</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.get_sprite_by_tile_identifier" href=3D"ht=
tps://docs.pyboy.dk/index.html#pyboy.PyBoy.get_sprite_by_tile_identifier">g=
et_sprite_by_tile_identifier</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.get_tile" href=3D"https://docs.pyboy.dk/i=
ndex.html#pyboy.PyBoy.get_tile">get_tile</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.rtc_lock_experimental" href=3D"https://do=
cs.pyboy.dk/index.html#pyboy.PyBoy.rtc_lock_experimental">rtc_lock_experime=
ntal</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.screen" href=3D"https://docs.pyboy.dk/ind=
ex.html#pyboy.PyBoy.screen">screen</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.memory" href=3D"https://docs.pyboy.dk/ind=
ex.html#pyboy.PyBoy.memory">memory</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.register_file" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoy.register_file">register_file</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.memory_scanner" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoy.memory_scanner">memory_scanner</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.tilemap_background" href=3D"https://docs.=
pyboy.dk/index.html#pyboy.PyBoy.tilemap_background">tilemap_background</a><=
/code></li>
<li><code><a title=3D"pyboy.PyBoy.tilemap_window" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoy.tilemap_window">tilemap_window</a></code></li>
<li><code><a title=3D"pyboy.PyBoy.cartridge_title" href=3D"https://docs.pyb=
oy.dk/index.html#pyboy.PyBoy.cartridge_title">cartridge_title</a></code></l=
i>
<li><code><a title=3D"pyboy.PyBoy.game_wrapper" href=3D"https://docs.pyboy.=
dk/index.html#pyboy.PyBoy.game_wrapper">game_wrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title=3D"pyboy.PyBoyMemoryView" href=3D"https://docs.pyboy.dk/=
index.html#pyboy.PyBoyMemoryView">PyBoyMemoryView</a></code></h4>
</li>
<li>
<h4><code><a title=3D"pyboy.PyBoyRegisterFile" href=3D"https://docs.pyboy.d=
k/index.html#pyboy.PyBoyRegisterFile">PyBoyRegisterFile</a></code></h4>
<ul class=3D"two-column">
<li><code><a title=3D"pyboy.PyBoyRegisterFile.A" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoyRegisterFile.A">A</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.F" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoyRegisterFile.F">F</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.B" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoyRegisterFile.B">B</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.C" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoyRegisterFile.C">C</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.D" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoyRegisterFile.D">D</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.E" href=3D"https://docs.pyboy=
.dk/index.html#pyboy.PyBoyRegisterFile.E">E</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.HL" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoyRegisterFile.HL">HL</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.SP" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoyRegisterFile.SP">SP</a></code></li>
<li><code><a title=3D"pyboy.PyBoyRegisterFile.PC" href=3D"https://docs.pybo=
y.dk/index.html#pyboy.PyBoyRegisterFile.PC">PC</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id=3D"footer">
<p>Generated by <a href=3D"https://pdoc3.github.io/pdoc"><cite>pdoc</cite> =
0.10.0</a>.</p>
</footer>



</body></html>
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-f8f9f4c2-91cf-4773-bd31-e89e96c94627@mhtml.blink

@charset "utf-8";

.flex { display: flex !important; }

body { line-height: 1.5em; }

#content { padding: 20px; }

#sidebar { padding: 30px; overflow: hidden; }

.http-server-breadcrumbs { font-size: 130%; margin: 0px 0px 15px; }

#footer { font-size: 0.75em; padding: 5px 30px; border-top: 1px solid rgb(2=
21, 221, 221); text-align: right; }

#footer p { margin: 0px 0px 0px 1em; display: inline-block; }

#footer p:last-child { margin-right: 30px; }

h1, h2, h3, h4, h5 { font-weight: 300; }

h1 { font-size: 2.5em; line-height: 1.1em; }

h2 { font-size: 1.75em; margin: 1em 0px 0.5em; }

h3 { font-size: 1.4em; margin: 25px 0px 10px; }

h4 { margin: 0px; font-size: 105%; }

a { color: rgb(0, 85, 136); text-decoration: none; transition: color 0.3s e=
ase-in-out 0s; }

a:hover { color: rgb(238, 136, 34); }

.title code { font-weight: bold; }

h2[id^=3D"header-"] { margin-top: 2em; }

.ident { color: rgb(153, 0, 0); }

pre code { background: rgb(248, 248, 248); font-size: 0.8em; line-height: 1=
.4em; }

code { background: rgb(242, 242, 241); padding: 1px 4px; overflow-wrap: bre=
ak-word; }

h1 code { background: transparent; }

pre { background: rgb(248, 248, 248); border-width: 1px 0px; border-right-s=
tyle: initial; border-left-style: initial; border-right-color: initial; bor=
der-left-color: initial; border-image: initial; border-top-style: solid; bo=
rder-top-color: rgb(204, 204, 204); border-bottom-style: solid; border-bott=
om-color: rgb(204, 204, 204); margin: 1em 0px; padding: 1ex; }

#http-server-module-list { display: flex; flex-flow: column; }

#http-server-module-list div { display: flex; }

#http-server-module-list dt { min-width: 10%; }

#http-server-module-list p { margin-top: 0px; }

.toc ul, #index { list-style-type: none; margin: 0px; padding: 0px; }

#index code { background: transparent; }

#index h3 { border-bottom: 1px solid rgb(221, 221, 221); }

#index ul { padding: 0px; }

#index h4 { font-weight: bold; }

#index h4 + ul { margin-bottom: 0.6em; }

@media (min-width: 200ex) {
  #index .two-column { column-count: 2; }
}

@media (min-width: 300ex) {
  #index .two-column { column-count: 3; }
}

dl { margin-bottom: 2em; }

dl dl:last-child { margin-bottom: 4em; }

dd { margin: 0px 0px 1em 3em; }

#header-classes + dl > dd { margin-bottom: 3em; }

dd dd { margin-left: 2em; }

dd p { margin: 10px 0px; }

.name { background: rgb(238, 238, 238); font-weight: bold; font-size: 0.85e=
m; padding: 5px 10px; display: inline-block; min-width: 40%; }

.name:hover { background: rgb(224, 224, 224); }

.name > span:first-child { white-space: nowrap; }

.name.class > span:nth-child(2) { margin-left: 0.4em; }

.inherited { color: rgb(153, 153, 153); border-left: 5px solid rgb(238, 238=
, 238); padding-left: 1em; }

.inheritance em { font-style: normal; font-weight: bold; }

.desc h2 { font-weight: 400; font-size: 1.25em; }

.desc h3 { font-size: 1em; }

.desc dt code { background: inherit; }

.source summary, .git-link-div { color: rgb(102, 102, 102); text-align: rig=
ht; font-weight: 400; font-size: 0.8em; text-transform: uppercase; }

.source summary > * { white-space: nowrap; cursor: pointer; }

.git-link { color: inherit; margin-left: 1em; }

.source pre { max-height: 500px; overflow: auto; margin: 0px; }

.source pre code { font-size: 12px; overflow: visible; }

.hlist { list-style: none; }

.hlist li { display: inline; }

.hlist li::after { content: ",=E2=80=82"; }

.hlist li:last-child::after { content: none; }

.hlist .hlist { display: inline; padding-left: 1em; }

img { max-width: 100%; }

.admonition { padding: 0.1em 0.5em; margin-bottom: 1em; }

.admonition-title { font-weight: bold; }

.admonition.note, .admonition.info, .admonition.important { background: rgb=
(170, 238, 255); }

.admonition.todo, .admonition.versionadded, .admonition.tip, .admonition.hi=
nt { background: rgb(221, 255, 221); }

.admonition.warning, .admonition.versionchanged, .admonition.deprecated { b=
ackground: rgb(255, 221, 68); }

.admonition.error, .admonition.danger, .admonition.caution { background: li=
ghtpink; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-4c5add56-c960-40d9-877a-ae82dbdb270c@mhtml.blink

@charset "utf-8";

@media screen and (min-width: 700px) {
  #sidebar { width: 30%; }
  #content { width: 70%; max-width: 100ch; padding: 3em 4em; border-left: 1=
px solid rgb(221, 221, 221); }
  pre code { font-size: 0.8em; }
  .item .name { font-size: 1em; }
  main { display: flex; flex-direction: row-reverse; justify-content: flex-=
end; }
  .toc ul ul, #index ul { padding-left: 1.5em; }
  .toc > ul > li { margin-top: 0.5em; }
}
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-48a2acaa-0840-4821-98e3-28b1f23329fe@mhtml.blink

@charset "utf-8";

@media print {
  #sidebar h1 { break-before: page; }
  .source { display: none; }
}

@media print {
  * { background: transparent !important; color: rgb(0, 0, 0) !important; b=
ox-shadow: none !important; text-shadow: none !important; }
  a[href]::after { content: " (" attr(href) ")"; font-size: 90%; }
  a[href][title]::after { content: none; }
  abbr[title]::after { content: " (" attr(title) ")"; }
  .ir a::after, a[href^=3D"javascript:"]::after, a[href^=3D"#"]::after { co=
ntent: ""; }
  pre, blockquote { border: 1px solid rgb(153, 153, 153); break-inside: avo=
id; }
  thead { display: table-header-group; }
  tr, img { break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h1, h2, h3, h4, h5, h6 { break-after: avoid; }
}
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-955b1811-73a3-4a0a-bd92-692c2e1ce0d1@mhtml.blink

@charset "utf-8";

.MathJax_Hover_Frame { border-radius: 0.25em; box-shadow: rgb(136, 51, 170)=
 0px 0px 15px; display: inline-block; position: absolute; border: 1px solid=
 rgb(170, 102, 221) !important; }

.MathJax_Menu_Button .MathJax_Hover_Arrow { position: absolute; cursor: poi=
nter; display: inline-block; border: 2px solid rgb(170, 170, 170); border-r=
adius: 4px; font-family: "Courier New", Courier; font-size: 9px; color: rgb=
(240, 240, 240); }

.MathJax_Menu_Button .MathJax_Hover_Arrow span { display: block; background=
-color: rgb(170, 170, 170); border: 1px solid; border-radius: 3px; line-hei=
ght: 0; padding: 4px; }

.MathJax_Hover_Arrow:hover { color: white !important; border: 2px solid rgb=
(204, 204, 204) !important; }

.MathJax_Hover_Arrow:hover span { background-color: rgb(204, 204, 204) !imp=
ortant; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-a9dbe30a-3e08-472c-bb8a-cc4025cad437@mhtml.blink

@charset "utf-8";

#MathJax_About { position: fixed; left: 50%; width: auto; text-align: cente=
r; border: 3px outset; padding: 1em 2em; background-color: rgb(221, 221, 22=
1); color: black; cursor: default; font-family: message-box; font-size: 120=
%; font-style: normal; text-indent: 0px; text-transform: none; line-height:=
 normal; letter-spacing: normal; word-spacing: normal; overflow-wrap: norma=
l; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; box=
-shadow: rgb(128, 128, 128) 0px 10px 20px; }

#MathJax_About.MathJax_MousePost { outline: none; }

.MathJax_Menu { position: absolute; background-color: white; color: black; =
width: auto; padding: 2px; border: 1px solid rgb(204, 204, 204); margin: 0p=
x; cursor: default; font-style: ; font-variant: normal; font-weight: ; font=
-stretch: ; font-size: ; font-family: ; font-optical-sizing: ; font-kerning=
: ; font-feature-settings: ; font-variation-settings: ; text-align: left; t=
ext-indent: 0px; text-transform: none; line-height: normal; letter-spacing:=
 normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; =
float: none; z-index: 201; box-shadow: rgb(128, 128, 128) 0px 10px 20px; }

.MathJax_MenuItem { padding: 2px 2em; background: transparent; }

.MathJax_MenuArrow { position: absolute; right: 0.5em; padding-top: 0.25em;=
 color: rgb(102, 102, 102); font-size: 0.75em; }

.MathJax_MenuActive .MathJax_MenuArrow { color: white; }

.MathJax_MenuArrow.RTL { left: 0.5em; right: auto; }

.MathJax_MenuCheck { position: absolute; left: 0.7em; }

.MathJax_MenuCheck.RTL { right: 0.7em; left: auto; }

.MathJax_MenuRadioCheck { position: absolute; left: 1em; }

.MathJax_MenuRadioCheck.RTL { right: 1em; left: auto; }

.MathJax_MenuLabel { padding: 2px 2em 4px 1.33em; font-style: italic; }

.MathJax_MenuRule { border-top: 1px solid rgb(204, 204, 204); margin: 4px 1=
px 0px; }

.MathJax_MenuDisabled { color: graytext; }

.MathJax_MenuActive { background-color: highlight; color: highlighttext; }

.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus { background-color: r=
gb(232, 232, 232); }

.MathJax_ContextMenu:focus { outline: none; }

.MathJax_ContextMenu .MathJax_MenuItem:focus { outline: none; }

#MathJax_AboutClose { top: 0.2em; right: 0.2em; }

.MathJax_Menu .MathJax_MenuClose { top: -10px; left: -10px; }

.MathJax_MenuClose { position: absolute; cursor: pointer; display: inline-b=
lock; border: 2px solid rgb(170, 170, 170); border-radius: 18px; font-famil=
y: "Courier New", Courier; font-size: 24px; color: rgb(240, 240, 240); }

.MathJax_MenuClose span { display: block; background-color: rgb(170, 170, 1=
70); border: 1.5px solid; border-radius: 18px; line-height: 0; padding: 8px=
 0px 6px; }

.MathJax_MenuClose:hover { color: white !important; border: 2px solid rgb(2=
04, 204, 204) !important; }

.MathJax_MenuClose:hover span { background-color: rgb(204, 204, 204) !impor=
tant; }

.MathJax_MenuClose:hover:focus { outline: none; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-4ae5926d-a767-4682-8dd1-705f0032e30b@mhtml.blink

@charset "utf-8";

.MathJax_Preview .MJXf-math { color: inherit !important; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-411f6874-bea2-43d5-988c-a38a6c1d45d5@mhtml.blink

@charset "utf-8";

.MJX_Assistive_MathML { top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px)=
; user-select: none; position: absolute !important; padding: 1px 0px 0px !i=
mportant; border: 0px !important; height: 1px !important; width: 1px !impor=
tant; overflow: hidden !important; display: block !important; }

.MJX_Assistive_MathML.MJX_Assistive_MathML_Block { width: 100% !important; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-990ddaa9-fc7f-47ac-bc6b-8ea109ceacfe@mhtml.blink

@charset "utf-8";

#MathJax_Zoom { position: absolute; background-color: rgb(240, 240, 240); o=
verflow: auto; display: block; z-index: 301; padding: 0.5em; border: 1px so=
lid black; margin: 0px; font-weight: normal; font-style: normal; text-align=
: left; text-indent: 0px; text-transform: none; line-height: normal; letter=
-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space:=
 nowrap; float: none; box-sizing: content-box; box-shadow: rgb(170, 170, 17=
0) 5px 5px 15px; }

#MathJax_ZoomOverlay { position: absolute; left: 0px; top: 0px; z-index: 30=
0; display: inline-block; width: 100%; height: 100%; border: 0px; padding: =
0px; margin: 0px; background-color: white; opacity: 0; }

#MathJax_ZoomFrame { position: relative; display: inline-block; height: 0px=
; width: 0px; }

#MathJax_ZoomEventTrap { position: absolute; left: 0px; top: 0px; z-index: =
302; display: inline-block; border: 0px; padding: 0px; margin: 0px; backgro=
und-color: white; opacity: 0; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-67ae9d7c-82c3-4c78-8764-5db53d1e67bb@mhtml.blink

@charset "utf-8";

.MathJax_Preview { color: rgb(136, 136, 136); }

#MathJax_Message { position: fixed; left: 1em; bottom: 1.5em; background-co=
lor: rgb(230, 230, 230); border: 1px solid rgb(149, 149, 149); margin: 0px;=
 padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto;=
 white-space: nowrap; }

#MathJax_MSIE_Frame { position: absolute; top: 0px; left: 0px; width: 0px; =
z-index: 101; border: 0px; margin: 0px; padding: 0px; }

.MathJax_Error { color: rgb(204, 0, 0); font-style: italic; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-40fc8bd7-9d8e-4669-811a-c24898ff1469@mhtml.blink

@charset "utf-8";

.MJXp-script { font-size: 0.8em; }

.MJXp-right { transform-origin: right center; }

.MJXp-bold { font-weight: bold; }

.MJXp-italic { font-style: italic; }

.MJXp-scr { font-family: MathJax_Script, "Times New Roman", Times, STIXGene=
ral, serif; }

.MJXp-frak { font-family: MathJax_Fraktur, "Times New Roman", Times, STIXGe=
neral, serif; }

.MJXp-sf { font-family: MathJax_SansSerif, "Times New Roman", Times, STIXGe=
neral, serif; }

.MJXp-cal { font-family: MathJax_Caligraphic, "Times New Roman", Times, STI=
XGeneral, serif; }

.MJXp-mono { font-family: MathJax_Typewriter, "Times New Roman", Times, STI=
XGeneral, serif; }

.MJXp-largeop { font-size: 150%; }

.MJXp-largeop.MJXp-int { vertical-align: -0.2em; }

.MJXp-math { display: inline-block; line-height: 1.2; text-indent: 0px; fon=
t-family: "Times New Roman", Times, STIXGeneral, serif; white-space: nowrap=
; border-collapse: collapse; }

.MJXp-display { display: block; text-align: center; margin: 1em 0px; }

.MJXp-math span { display: inline-block; }

.MJXp-box { display: block !important; text-align: center; }

.MJXp-box::after { content: " "; }

.MJXp-rule { display: block !important; margin-top: 0.1em; }

.MJXp-char { display: block !important; }

.MJXp-mo { margin: 0px 0.15em; }

.MJXp-mfrac { margin: 0px 0.125em; vertical-align: 0.25em; }

.MJXp-denom { display: inline-table !important; width: 100%; }

.MJXp-denom > * { display: table-row !important; }

.MJXp-surd { vertical-align: top; }

.MJXp-surd > * { display: block !important; }

.MJXp-script-box > * { display: table !important; height: 50%; }

.MJXp-script-box > * > * { display: table-cell !important; vertical-align: =
top; }

.MJXp-script-box > :last-child > * { vertical-align: bottom; }

.MJXp-script-box > * > * > * { display: block !important; }

.MJXp-mphantom { visibility: hidden; }

.MJXp-munderover, .MJXp-munder { display: inline-table !important; }

.MJXp-over { display: inline-block !important; text-align: center; }

.MJXp-over > * { display: block !important; }

.MJXp-munderover > *, .MJXp-munder > * { display: table-row !important; }

.MJXp-mtable { vertical-align: 0.25em; margin: 0px 0.125em; }

.MJXp-mtable > * { display: inline-table !important; vertical-align: middle=
; }

.MJXp-mtr { display: table-row !important; }

.MJXp-mtd { text-align: center; padding: 0.5em 0px 0px 0.5em; display: tabl=
e-cell !important; }

.MJXp-mtr > .MJXp-mtd:first-child { padding-left: 0px; }

.MJXp-mtr:first-child > .MJXp-mtd { padding-top: 0px; }

.MJXp-mlabeledtr { display: table-row !important; }

.MJXp-mlabeledtr > .MJXp-mtd:first-child { padding-left: 0px; }

.MJXp-mlabeledtr:first-child > .MJXp-mtd { padding-top: 0px; }

.MJXp-merror { background-color: rgb(255, 255, 136); color: rgb(204, 0, 0);=
 border: 1px solid rgb(204, 0, 0); padding: 1px 3px; font-style: normal; fo=
nt-size: 90%; }

.MJXp-scale0 { transform: scaleX(0); }

.MJXp-scale1 { transform: scaleX(0.1); }

.MJXp-scale2 { transform: scaleX(0.2); }

.MJXp-scale3 { transform: scaleX(0.3); }

.MJXp-scale4 { transform: scaleX(0.4); }

.MJXp-scale5 { transform: scaleX(0.5); }

.MJXp-scale6 { transform: scaleX(0.6); }

.MJXp-scale7 { transform: scaleX(0.7); }

.MJXp-scale8 { transform: scaleX(0.8); }

.MJXp-scale9 { transform: scaleX(0.9); }

.MathJax_PHTML .noError { font-size: 90%; text-align: left; color: black; p=
adding: 1px 3px; border: 1px solid; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css

@charset "utf-8";

html { line-height: 1.15; text-size-adjust: 100%; }

body { margin: 0px; }

h1 { font-size: 2em; margin: 0.67em 0px; }

hr { box-sizing: content-box; height: 0px; overflow: visible; }

pre { font-family: monospace, monospace; font-size: 1em; }

a { background-color: transparent; }

abbr[title] { border-bottom: none; text-decoration: underline dotted; }

b, strong { font-weight: bolder; }

code, kbd, samp { font-family: monospace, monospace; font-size: 1em; }

small { font-size: 80%; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-ali=
gn: baseline; }

sub { bottom: -0.25em; }

sup { top: -0.5em; }

img { border-style: none; }

button, input, optgroup, select, textarea { font-family: inherit; font-size=
: 100%; line-height: 1.15; margin: 0px; }

button, input { overflow: visible; }

button, select { text-transform: none; }

[type=3D"button"], [type=3D"reset"], [type=3D"submit"], button { appearance=
: button; }

fieldset { padding: 0.35em 0.75em 0.625em; }

legend { box-sizing: border-box; color: inherit; display: table; max-width:=
 100%; padding: 0px; white-space: normal; }

progress { vertical-align: baseline; }

textarea { overflow: auto; }

[type=3D"checkbox"], [type=3D"radio"] { box-sizing: border-box; padding: 0p=
x; }

[type=3D"number"]::-webkit-inner-spin-button, [type=3D"number"]::-webkit-ou=
ter-spin-button { height: auto; }

[type=3D"search"] { appearance: textfield; outline-offset: -2px; }

[type=3D"search"]::-webkit-search-decoration { appearance: none; }

::-webkit-file-upload-button { appearance: button; font: inherit; }

details { display: block; }

summary { display: list-item; }

template { display: none; }

[hidden] { display: none; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css

@charset "utf-8";

*, ::after, ::before { background-repeat: no-repeat; box-sizing: border-box=
; }

::after, ::before { text-decoration: inherit; vertical-align: inherit; }

html { cursor: default; font-family: system-ui, -apple-system, "Segoe UI", =
Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif, "Apple Color Emoji", "S=
egoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; line-height: 1.15; t=
ab-size: 4; text-size-adjust: 100%; word-break: break-word; }

body { margin: 0px; }

h1 { font-size: 2em; margin: 0.67em 0px; }

hr { height: 0px; overflow: visible; }

main { display: block; }

nav ol, nav ul { list-style: none; }

pre { font-family: Menlo, Consolas, "Roboto Mono", "Ubuntu Monospace", "Not=
o Mono", "Oxygen Mono", "Liberation Mono", monospace; font-size: 1em; }

a { background-color: transparent; }

abbr[title] { text-decoration: underline dotted; }

b, strong { font-weight: bolder; }

code, kbd, samp { font-family: Menlo, Consolas, "Roboto Mono", "Ubuntu Mono=
space", "Noto Mono", "Oxygen Mono", "Liberation Mono", monospace; font-size=
: 1em; }

small { font-size: 80%; }

::selection { background-color: rgb(179, 212, 252); color: rgb(0, 0, 0); te=
xt-shadow: none; }

audio, canvas, iframe, img, svg, video { vertical-align: middle; }

audio, video { display: inline-block; }

audio:not([controls]) { display: none; height: 0px; }

img { border-style: none; }

svg:not([fill]) { fill: currentcolor; }

svg:not(:root) { overflow: hidden; }

table { border-collapse: collapse; }

button, input, select, textarea { font-family: inherit; font-size: inherit;=
 line-height: inherit; }

button, input, select { margin: 0px; }

button { overflow: visible; text-transform: none; }

[type=3D"button"], [type=3D"reset"], [type=3D"submit"], button { appearance=
: button; }

fieldset { padding: 0.35em 0.75em 0.625em; }

input { overflow: visible; }

legend { color: inherit; display: table; max-width: 100%; white-space: norm=
al; }

progress { display: inline-block; vertical-align: baseline; }

select { text-transform: none; }

textarea { margin: 0px; overflow: auto; resize: vertical; }

[type=3D"checkbox"], [type=3D"radio"] { padding: 0px; }

[type=3D"search"] { appearance: textfield; outline-offset: -2px; }

::-webkit-inner-spin-button, ::-webkit-outer-spin-button { height: auto; }

::-webkit-input-placeholder { color: inherit; opacity: 0.54; }

::-webkit-search-decoration { appearance: none; }

::-webkit-file-upload-button { appearance: button; font: inherit; }

details { display: block; }

dialog { background-color: rgb(255, 255, 255); border: solid; color: rgb(0,=
 0, 0); display: block; height: fit-content; left: 0px; margin: auto; paddi=
ng: 1em; position: absolute; right: 0px; width: fit-content; }

dialog:not([open]) { display: none; }

summary { display: list-item; }

canvas { display: inline-block; }

template { display: none; }

[tabindex], a, area, button, input, label, select, summary, textarea { touc=
h-action: manipulation; }

[hidden] { display: none; }

[aria-busy=3D"true"] { cursor: progress; }

[aria-controls] { cursor: pointer; }

[aria-disabled=3D"true"], [disabled] { cursor: not-allowed; }

[aria-hidden=3D"false"][hidden]:not(:focus) { clip: rect(0px, 0px, 0px, 0px=
); display: inherit; position: absolute; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css

@charset "utf-8";

.hljs { display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51=
, 51); background: rgb(248, 248, 248); }

.hljs-comment, .hljs-quote { color: rgb(153, 153, 136); font-style: italic;=
 }

.hljs-keyword, .hljs-selector-tag, .hljs-subst { color: rgb(51, 51, 51); fo=
nt-weight: bold; }

.hljs-number, .hljs-literal, .hljs-variable, .hljs-template-variable, .hljs=
-tag .hljs-attr { color: rgb(0, 128, 128); }

.hljs-string, .hljs-doctag { color: rgb(221, 17, 68); }

.hljs-title, .hljs-section, .hljs-selector-id { color: rgb(153, 0, 0); font=
-weight: bold; }

.hljs-subst { font-weight: normal; }

.hljs-type, .hljs-class .hljs-title { color: rgb(68, 85, 136); font-weight:=
 bold; }

.hljs-tag, .hljs-name, .hljs-attribute { color: rgb(0, 0, 128); font-weight=
: normal; }

.hljs-regexp, .hljs-link { color: rgb(0, 153, 38); }

.hljs-symbol, .hljs-bullet { color: rgb(153, 0, 115); }

.hljs-built_in, .hljs-builtin-name { color: rgb(0, 134, 179); }

.hljs-meta { color: rgb(153, 153, 153); font-weight: bold; }

.hljs-deletion { background: rgb(255, 221, 221); }

.hljs-addition { background: rgb(221, 255, 221); }

.hljs-emphasis { font-style: italic; }

.hljs-strong { font-weight: bold; }
------MultipartBoundary--pQ7zWxEMJFkPGLspRCUN3xKTcXhiTN7tQGsc7x5kTh------
